<!DOCTYPE html>
<!--
Common Dispatch Console
Copyright (C) 2025 Brandon Cooper

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Common Dispatch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <!-- Opus Codec Library - trying multiple sources -->
    <script>
        // WebCodecs API is used directly for Opus - no external library needed
        window.opusLibraryLoaded = false;
        console.log('Opus will use WebCodecs API (built into modern browsers)');
    </script>
    <style>
        /* === CORE STYLES === */
        .page-stacked {
            border: 2px solid #10b981 !important;
            background-color: rgba(16, 185, 129, 0.1) !important;
            position: relative;
        }
        .page-stacked::before {
            content: "✓";
            position: absolute;
            top: 4px;
            left: 4px;
            color: #10b981;
            font-weight: bold;
            font-size: 0.8em;
        }

        /* RX/TX Indicators */
        .rx-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.9em;
            color: #10b981;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .rx-active {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }

        /* Resource Selected State */
        .resource-selected {
            background-color: rgba(93, 92, 222, 0.15) !important;
            border-color: #5D5CDE !important;
        }

        /* Resource Selectable Area */
        .resource-selectable {
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        .resource-selectable:hover {
            background-color: rgba(107, 114, 128, 0.1);
        }
        .resource-selected .resource-selectable:hover {
            background-color: rgba(93, 92, 222, 0.2);
        }

        /* Alert/Transmit Active States */
        .alert-tone-active, .transmit-active {
            background-color: #f59e0b !important;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
            animation: pulse 1s infinite;
        }

        /* Emergency States */
        .emergency-active {
            animation: emergency-pulse 0.5s infinite;
        }
        @keyframes emergency-pulse {
            0%, 100% { 
                border-color: #ef4444;
                box-shadow: 0 0 15px rgba(239, 68, 68, 0.7);
            }
            50% { 
                border-color: #fca5a5;
                box-shadow: 0 0 25px rgba(239, 68, 68, 0.9);
            }
        }
        .emergency-icon-active {
            animation: emergency-bg-flash 0.5s infinite;
        }
        @keyframes emergency-bg-flash {
            0%, 100% { background-color: #ef4444; }
            50% { background-color: #fca5a5; }
        }
        .emergency-btn-pulse {
            animation: emergency-btn-pulse 0.5s infinite;
        }
        @keyframes emergency-btn-pulse {
            0%, 100% { 
                background-color: #ef4444;
                transform: scale(1);
            }
            50% { 
                background-color: #dc2626;
                transform: scale(1.05);
            }
        }

        /* Priority Icon with Superscript Music Note */
        .priority-icon-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .priority-icon-wrapper .music-note-super {
            position: absolute;
            top: -4px;
            right: -6px;
            font-size: 0.5em;
            color: #1f2937;
        }
        .priority-icon-wrapper .music-note-super.active {
            color: #ef4444;
        }

        /* Alert Tone Icon with Subscript Music Note */
        .alert-icon-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }
        .alert-icon-wrapper .music-note-sub {
            font-size: 0.6em;
            vertical-align: sub;
            margin-left: 1px;
        }

        /* RSSI Meter */
        .rssi-meter {
            display: flex;
            gap: 1px;
            align-items: flex-end;
            height: 12px;
        }
        .rssi-bar {
            width: 3px;
            background-color: #3b82f6; /* Blue instead of green */
            border-radius: 1px;
            transition: height 0.1s ease;
        }
        .rssi-bar.inactive {
            background-color: #374151;
        }

        /* Caller ID Display */
        .caller-id {
            font-size: 0.7em;
            background-color: rgba(59, 130, 246, 0.2); /* Blue instead of green */
            padding: 1px 4px;
            border-radius: 3px;
            color: #3b82f6; /* Blue instead of green */
            font-weight: 500;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Modal Scrollbar */
        .modal-content::-webkit-scrollbar {
            width: 8px;
        }
        .modal-content::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 4px;
        }
        .modal-content::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        /* List Items */
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 4px;
            background-color: rgba(55, 65, 81, 0.5);
            transition: background-color 0.2s;
        }
        .list-item:hover {
            background-color: rgba(55, 65, 81, 0.8);
        }
        .list-item.selected {
            background-color: rgba(93, 92, 222, 0.3);
            border: 1px solid #5D5CDE;
        }

        /* Activity Log Section */
        .activity-log {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.01s ease;
        }
        .activity-log.expanded {
            max-height: 200px;
            overflow-y: auto;
        }

        /* Instant Transmit Button (Resource) */
        .instant-tx-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* Stacked Control Buttons */
        .stacked-controls {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .stacked-controls button {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Expand Button */
        .expand-btn {
            width: 100%;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0 0 6px 6px;
            transition: background-color 0.15s ease;
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        'resource-active': '#10B981',
                        'resource-busy': '#EF4444',
                        'resource-patch': '#F59E0B'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white transition-colors duration-200">
    <!-- Header -->
    <header class="bg-primary text-white shadow-lg">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center">
                <h1 id="consoleTitle" class="text-xl font-bold">Common Dispatch</h1>
            </div>
            <div class="flex items-center space-x-2">
                <!-- Clock Display -->
                <div id="clockDisplay" class="hidden text-lg font-mono font-semibold px-3 py-1.5 bg-white bg-opacity-15 rounded-lg">
                    <i class="fas fa-clock mr-1.5"></i><span id="clockTime">12:00:00</span>
                </div>
                <!-- Radio Aliases Button -->
                <button id="aliasesBtn" class="p-2 hover:bg-white hover:bg-opacity-20 rounded-lg transition-colors" title="Radio Aliases">
                    <i class="fas fa-address-book"></i>
                </button>
                <!-- Emergency Button -->
                <button id="emergencyBtn" class="p-2 hover:bg-white hover:bg-opacity-20 rounded-lg transition-colors relative" title="Emergency Alerts">
                    <i class="fas fa-triangle-exclamation"></i>
                    <span id="emergencyBadge" class="hidden absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center font-bold">0</span>
                </button>
                <!-- Settings Button -->
                <button id="settingsBtn" class="p-2 hover:bg-white hover:bg-opacity-20 rounded-lg transition-colors" title="Settings">
                    <i class="fas fa-cog"></i>
                </button>
                <!-- Help Button -->
                <button id="helpBtn" class="p-2 hover:bg-white hover:bg-opacity-20 rounded-lg transition-colors" title="Help">
                    <i class="fas fa-question-circle"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Console -->
    <main class="container mx-auto px-4 py-6">
        <!-- Master Controls -->
        <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-6 shadow-sm">
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4">
                <!-- Volume Controls (Stacked) + VU Meter -->
                <div class="space-y-3">
                    <!-- Master Volume -->
                    <div class="space-y-1">
                        <label class="text-xs font-medium">Master Volume</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="masterVolume" min="0" max="7" value="5" step="1"
                                class="flex-1 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            <span id="masterVolumeDisplay" class="text-xs w-6 text-center">5</span>
                        </div>
                    </div>
                    <!-- Microphone Volume -->
                    <div class="space-y-1">
                        <label class="text-xs font-medium">Microphone</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="micVolume" min="0" max="7" value="6" step="1"
                                class="flex-1 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            <span id="micVolumeDisplay" class="text-xs w-6 text-center">6</span>
                        </div>
                    </div>
                    <!-- VU Meter -->
                    <div class="flex items-center gap-2 h-6">
                        <i id="vuMeterIcon" class="fas fa-volume-off text-gray-400 w-4 text-center" style="visibility: hidden;"></i>
                        <div id="vuMeterContainer" class="flex-1 h-3 bg-gray-300 dark:bg-gray-600 rounded overflow-hidden">
                            <div id="vuMeterBar" class="h-full bg-green-500 transition-all duration-75" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <!-- Muting Button -->
                <div class="space-y-2">
                    <label class="text-sm font-medium">Muting</label>
                    <button id="muteBtn"
                        class="w-full h-12 p-3 bg-gray-500 hover:bg-gray-600 text-white rounded-lg font-medium transition-colors text-xs">
                        <i id="muteIcon" class="fas fa-volume-up"></i>
                    </button>
                </div>

                <!-- General Transmit -->
                <div class="space-y-2">
                    <label class="text-sm font-medium">General Transmit</label>
                    <button id="generalTransmitBtn"
                        class="w-full h-12 p-3 bg-red-500 hover:bg-red-600 text-white rounded-lg font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed relative">
                        <span id="generalTransmitIcon">
                            <i class="fas fa-bolt"></i>
                        </span>
                    </button>
                </div>

                <!-- Paging Control -->
                <div class="space-y-2">
                    <label class="text-sm font-medium">Paging</label>
                    <button id="transmitStackBtn"
                        class="w-full h-12 p-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-medium transition-colors">
                        <span id="transmitStackIcon">
                            <i class="fas fa-pager"></i>
                            <i class="fas fa-tower-cell ml-1"></i>
                        </span>
                    </button>
                </div>

                <!-- Alerting Controls -->
                <div class="space-y-2">
                    <label class="text-sm font-medium text-center block">Alerting</label>
                    <div class="grid grid-cols-2 gap-1 h-12">
                        <button id="alertTone1Btn"
                            class="flex-1 p-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded font-medium transition-colors relative text-xs">
                            <span class="alert-icon-wrapper">
                                <span class="font-bold text-lg">1</span>
                                <i class="fas fa-bolt"></i>
                                <i class="fas fa-music music-note-sub"></i>
                            </span>
                        </button>
                        <button id="alertTone2Btn"
                            class="flex-1 p-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded font-medium transition-colors relative text-xs">
                            <span class="alert-icon-wrapper">
                                <span class="font-bold text-lg">2</span>
                                <i class="fas fa-bolt"></i>
                                <i class="fas fa-music music-note-sub"></i>
                            </span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Resources Grid -->
        <div id="resourcesGrid" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6 mb-6 items-start">
            <!-- Resources will be populated here -->
        </div>

        <!-- Pages Grid -->
        <div id="pagesGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-4 mb-6">
            <!-- Pages will be populated here -->
        </div>

        <!-- Add Buttons -->
        <div class="text-center space-x-4">
            <button id="addResourceBtn"
                class="px-6 py-3 bg-primary hover:bg-primary/80 text-white rounded-lg font-medium transition-colors">
                <i class="fas fa-plus mr-2"></i>Add Resource
            </button>
            <button id="addPageBtn"
                class="px-6 py-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-medium transition-colors">
                <i class="fas fa-plus mr-2"></i>Add Page
            </button>
        </div>
    </main>
    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold">Settings</h2>
                    <button onclick="hideModal('settingsModal')" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <div class="space-y-4">
                    <!-- Console Name -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Console Name</label>
                        <input type="text" id="consoleNameInput" value="Common Dispatch"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                    </div>

                    <!-- Theme -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Theme</label>
                        <select id="themeSelect"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                            <option value="system">System Default</option>
                            <option value="light">Light</option>
                            <option value="dark">Dark</option>
                        </select>
                    </div>

                    <!-- Clock Display -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Clock Display</label>
                        <div class="space-y-2">
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Show Clock in Header</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="showClockToggle" class="sr-only peer" onchange="toggleClockOptions()">
                                    <div class="w-11 h-6 bg-gray-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                                </label>
                            </div>
                            <div id="clockFormatOption" class="hidden pl-4">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm">Time Format</span>
                                    <select id="clockFormatSelect" class="p-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-sm">
                                        <option value="12">12-hour</option>
                                        <option value="24">24-hour</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Volume Settings -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Volume Settings</label>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-sm">Selected Resource Volume</span>
                                <div class="flex items-center space-x-2">
                                    <input type="range" id="selectedVolumeSlider" min="0" max="7" value="7" step="1"
                                        class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                                        oninput="document.getElementById('selectedVolumeValue').textContent = this.value">
                                    <span id="selectedVolumeValue" class="text-sm w-8 text-center">7</span>
                                </div>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-sm">Unselected Resource Volume</span>
                                <div class="flex items-center space-x-2">
                                    <input type="range" id="unselectedVolumeSlider" min="0" max="7" value="5" step="1"
                                        class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                                        oninput="document.getElementById('unselectedVolumeValue').textContent = this.value">
                                    <span id="unselectedVolumeValue" class="text-sm w-8 text-center">5</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Audio Routing Info -->
                    <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-3">
                        <label class="block text-sm font-medium mb-2">Audio Routing</label>
                        <p class="text-sm text-gray-600 dark:text-gray-400">
                            <i class="fas fa-headphones mr-1"></i> Selected → Left Channel<br>
                            <i class="fas fa-headphones mr-1"></i> Unselected → Right Channel
                        </p>
                    </div>

                    <!-- RSSI Display Toggle -->
                    <div>
                        <label class="flex items-center justify-between cursor-pointer">
                            <span class="text-sm font-medium">Show RSSI on Resources</span>
                            <input type="checkbox" id="showRssiToggle" checked
                                class="w-5 h-5 text-primary rounded focus:ring-primary cursor-pointer">
                        </label>
                    </div>

                    <!-- Stack Light Toggle -->
                    <div>
                        <label class="flex items-center justify-between cursor-pointer">
                            <span class="text-sm font-medium">Enable Stack Light</span>
                            <input type="checkbox" id="stackLightToggle"
                                onchange="toggleStackLightSettings()"
                                class="w-5 h-5 text-primary rounded focus:ring-primary cursor-pointer">
                        </label>
                        <div id="stackLightSettingsBtn" class="hidden mt-2">
                            <button type="button" onclick="showModal('stackLightModal')"
                                class="w-full p-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition-colors flex items-center justify-center">
                                <i class="fas fa-cog mr-2"></i>Stack Light Settings
                            </button>
                        </div>
                    </div>

                    <!-- PTT Keybinding -->
                    <div>
                        <label class="block text-sm font-medium mb-2">General Transmit (PTT) Key</label>
                        <div id="pttKeyDisplay" class="text-sm text-gray-600 dark:text-gray-400 mb-2">Currently: Space</div>
                        <button type="button" id="setPttKeyBtn" class="w-full p-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors">
                            Click to Set Key
                        </button>
                    </div>

                    <!-- Console ID Settings -->
                    <div class="border-t border-gray-300 dark:border-gray-600 pt-4 mt-4">
                        <label class="block text-sm font-medium mb-3">Console ID Transmission</label>
                        <label class="flex items-center justify-between cursor-pointer mb-3">
                            <span class="text-sm">Enable Console ID</span>
                            <input type="checkbox" id="enableConsoleIdToggle"
                                class="w-5 h-5 text-primary rounded focus:ring-primary cursor-pointer">
                        </label>
                        <div id="consoleIdSettings" class="space-y-3 hidden">
                            <div>
                                <label class="block text-xs text-gray-500 mb-1">DTMF String (1-10 digits)</label>
                                <input type="text" id="consoleIdString" placeholder="e.g., *123#" maxlength="10"
                                    class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                            </div>
                            <div>
                                <label class="block text-xs text-gray-500 mb-1">When to Send</label>
                                <select id="consoleIdTiming"
                                    class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                                    <option value="start">Start of Transmission</option>
                                    <option value="end">End of Transmission</option>
                                    <option value="both">Both Start and End</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Configuration Management -->
                    <div class="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                        <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">
                            <i class="fas fa-database mr-2"></i>Configuration Management
                        </h3>
                        <div class="grid grid-cols-3 gap-2">
                            <button onclick="exportConfiguration()" 
                                class="p-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-medium transition-colors">
                                <i class="fas fa-download mr-1"></i>Export
                            </button>
                            <button onclick="document.getElementById('importConfigInput').click()" 
                                class="p-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm font-medium transition-colors">
                                <i class="fas fa-upload mr-1"></i>Import
                            </button>
                            <button onclick="clearConfiguration()" 
                                class="p-2 bg-red-500 hover:bg-red-600 text-white rounded-lg text-sm font-medium transition-colors">
                                <i class="fas fa-trash mr-1"></i>Clear
                            </button>
                        </div>
                        <input type="file" id="importConfigInput" accept=".json" onchange="importConfiguration(event)" class="hidden">
                        <p class="text-xs text-gray-500 mt-2">Export saves all settings, resources, aliases, and pages to a JSON file.</p>
                    </div>

                    <!-- Apply Button -->
                    <button onclick="applySettings(); hideModal('settingsModal')" 
                        class="w-full p-3 bg-primary hover:bg-primary/80 text-white rounded-lg font-medium transition-colors mt-4">
                        Apply Settings
                    </button>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Radio Aliases Modal -->
    <div id="aliasesModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold"><i class="fas fa-address-book mr-2"></i>Radio Aliases</h2>
                    <button onclick="hideModal('aliasesModal')" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Alias List -->
                <div id="aliasListContainer" class="max-h-60 overflow-y-auto mb-4 border border-gray-200 dark:border-gray-700 rounded-lg">
                    <div id="aliasList" class="p-2">
                        <!-- Aliases populated here -->
                    </div>
                    <div id="noAliasesMsg" class="text-center text-gray-500 py-6">
                        <i class="fas fa-user-slash text-2xl mb-2"></i>
                        <p>No aliases configured</p>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex space-x-2 mb-4">
                    <button onclick="showAddAliasModal()" class="flex-1 p-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors">
                        <i class="fas fa-plus mr-1"></i> Add
                    </button>
                    <button id="deleteAliasBtn" onclick="deleteSelectedAliases()" class="flex-1 p-2 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <i class="fas fa-trash mr-1"></i> Delete
                    </button>
                    <button onclick="toggleAliasSettings()" class="p-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition-colors">
                        <i class="fas fa-cog"></i>
                    </button>
                </div>

                <!-- Alias Settings Panel -->
                <div id="aliasSettingsPanel" class="hidden border-t border-gray-300 dark:border-gray-600 pt-4">
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm font-medium">Enable Radio Alias Decoding</span>
                        <input type="checkbox" id="enableAliasDecoding" checked
                            class="w-5 h-5 text-primary rounded focus:ring-primary cursor-pointer">
                    </label>
                    <p class="text-xs text-gray-500 mt-2">When enabled, DTMF IDs at the start/end of transmissions will be decoded and displayed as aliases.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Alias Modal -->
    <div id="aliasEditModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-sm">
            <div class="p-6">
                <h3 id="aliasEditTitle" class="text-lg font-bold mb-4">Add Radio Alias</h3>
                <form id="aliasForm" onsubmit="saveAlias(event)" class="space-y-4">
                    <input type="hidden" id="editingAliasId" value="">
                    <div>
                        <label class="block text-sm font-medium mb-2">Alias Name</label>
                        <input type="text" id="aliasName" required placeholder="e.g., Unit 1"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700">
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2">DTMF ID</label>
                        <input type="text" id="aliasDtmfId" required maxlength="10" placeholder="e.g., 101"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 font-mono">
                        <p class="text-xs text-gray-500 mt-1">Valid: 0-9, A-D, *, # (1-10 characters)</p>
                    </div>
                    <div class="flex space-x-3 pt-2">
                        <button type="button" onclick="hideModal('aliasEditModal')"
                            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700">
                            Cancel
                        </button>
                        <button type="submit"
                            class="flex-1 p-2 bg-primary hover:bg-primary/80 text-white rounded-lg">
                            Save
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Emergency Modal -->
    <div id="emergencyModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold text-red-500"><i class="fas fa-triangle-exclamation mr-2"></i>Emergency Alerts</h2>
                    <button onclick="hideModal('emergencyModal')" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Emergency List -->
                <div id="emergencyListContainer" class="max-h-60 overflow-y-auto mb-4 border border-gray-200 dark:border-gray-700 rounded-lg">
                    <div id="emergencyList" class="p-2">
                        <!-- Emergencies populated here -->
                    </div>
                    <div id="noEmergenciesMsg" class="text-center text-gray-500 py-6">
                        <i class="fas fa-check-circle text-2xl mb-2 text-green-500"></i>
                        <p>No emergency events</p>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex space-x-2 mb-4">
                    <button id="acknowledgeEmergencyBtn" onclick="acknowledgeAllEmergencies()" 
                        class="flex-1 p-2 bg-gray-400 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <i class="fas fa-check-circle mr-1"></i> Acknowledge All
                    </button>
                    <button onclick="toggleEmergencySettings()" class="p-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg transition-colors">
                        <i class="fas fa-cog"></i>
                    </button>
                </div>

                <!-- Emergency Settings Panel -->
                <div id="emergencySettingsPanel" class="hidden border-t border-gray-300 dark:border-gray-600 pt-4 space-y-3">
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm font-medium">Enable Emergency Alerts</span>
                        <input type="checkbox" id="enableEmergencyAlerts" checked
                            class="w-5 h-5 text-primary rounded focus:ring-primary cursor-pointer">
                    </label>
                    <div>
                        <label class="block text-sm font-medium mb-2">Emergency Trigger DTMF</label>
                        <input type="text" id="emergencyTriggerDtmf" placeholder="e.g., *911# or 555" maxlength="10"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 font-mono">
                        <p class="text-xs text-gray-500 mt-1">DTMF string that triggers emergency alert (1-10 digits)</p>
                    </div>
                    <button onclick="saveEmergencySettings()" 
                        class="w-full p-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-medium transition-colors">
                        <i class="fas fa-save mr-2"></i>Save Emergency Settings
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Resource Modal -->
    <div id="resourceModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="resourceModalTitle" class="text-xl font-bold">Add Resource</h2>
                    <button onclick="hideModal('resourceModal')" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <form id="resourceForm" onsubmit="saveResource(event)" class="space-y-4">
                    <input type="hidden" id="editingResourceId" value="">

                    <div>
                        <label class="block text-sm font-medium mb-2">Resource Name</label>
                        <input type="text" id="resourceName" required placeholder="e.g., Fire Dispatch"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Operation Mode</label>
                        <select id="operationMode" onchange="updateOperationModeFields()"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                            <option value="simplex">Simplex</option>
                            <option value="half-duplex">Half-Duplex</option>
                        </select>
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Receive Frequency (MHz)</label>
                        <input type="number" id="frequency" step="0.00001" required placeholder="151.82000"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base font-mono">
                        <p class="text-xs text-gray-500 mt-1">VHF: 134-174 MHz | UHF: 400-480 MHz</p>
                    </div>

                    <div id="transmitFreqDiv" class="hidden">
                        <label class="block text-sm font-medium mb-2">Transmit Frequency (MHz)</label>
                        <input type="number" id="transmitFrequency" step="0.00001" placeholder="156.82000"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base font-mono">
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Tone Type</label>
                        <select id="toneType" onchange="updateToneFields()"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                            <option value="csq">CSQ (Carrier Squelch)</option>
                            <option value="ctcss">CTCSS / PL Tone</option>
                        </select>
                    </div>

                    <!-- CTCSS Options -->
                    <div id="ctcssDiv" class="hidden">
                        <label class="block text-sm font-medium mb-2">CTCSS Tone</label>
                        <select id="ctcssCode"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                            <option value="67.0">67.0 Hz</option>
                            <option value="71.9">71.9 Hz</option>
                            <option value="74.4">74.4 Hz</option>
                            <option value="77.0">77.0 Hz</option>
                            <option value="79.7">79.7 Hz</option>
                            <option value="82.5">82.5 Hz</option>
                            <option value="85.4">85.4 Hz</option>
                            <option value="88.5">88.5 Hz</option>
                            <option value="91.5">91.5 Hz</option>
                            <option value="94.8">94.8 Hz</option>
                            <option value="97.4">97.4 Hz</option>
                            <option value="100.0">100.0 Hz</option>
                            <option value="103.5">103.5 Hz</option>
                            <option value="107.2">107.2 Hz</option>
                            <option value="110.9">110.9 Hz</option>
                            <option value="114.8">114.8 Hz</option>
                            <option value="118.8">118.8 Hz</option>
                            <option value="123.0" selected>123.0 Hz</option>
                            <option value="127.3">127.3 Hz</option>
                            <option value="131.8">131.8 Hz</option>
                            <option value="136.5">136.5 Hz</option>
                            <option value="141.3">141.3 Hz</option>
                            <option value="146.2">146.2 Hz</option>
                            <option value="151.4">151.4 Hz</option>
                            <option value="156.7">156.7 Hz</option>
                            <option value="162.2">162.2 Hz</option>
                            <option value="167.9">167.9 Hz</option>
                            <option value="173.8">173.8 Hz</option>
                            <option value="179.9">179.9 Hz</option>
                            <option value="186.2">186.2 Hz</option>
                            <option value="192.8">192.8 Hz</option>
                            <option value="203.5">203.5 Hz</option>
                            <option value="210.7">210.7 Hz</option>
                            <option value="218.1">218.1 Hz</option>
                            <option value="225.7">225.7 Hz</option>
                            <option value="233.6">233.6 Hz</option>
                            <option value="241.8">241.8 Hz</option>
                            <option value="250.3">250.3 Hz</option>
                        </select>
                    </div>


                    <!-- Squelch Level -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Squelch Sensitivity</label>
                        <div class="flex items-center space-x-3">
                            <span class="text-xs text-gray-500">Open</span>
                            <input type="range" id="squelchLevel" min="0" max="8" value="4"
                                oninput="document.getElementById('squelchValue').textContent = this.value"
                                class="flex-1 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                            <span class="text-xs text-gray-500">Tight</span>
                            <span id="squelchValue" class="text-sm font-medium w-6 text-center">4</span>
                        </div>
                    </div>

                    <!-- Transmit Power -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Transmit Power</label>
                        <div class="flex items-center space-x-4">
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="txPower" id="txPowerHigh" value="high" checked
                                    class="w-4 h-4 text-primary focus:ring-primary cursor-pointer">
                                <span class="ml-2 text-sm">High</span>
                            </label>
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="txPower" id="txPowerLow" value="low"
                                    class="w-4 h-4 text-primary focus:ring-primary cursor-pointer">
                                <span class="ml-2 text-sm">Low</span>
                            </label>
                        </div>
                    </div>

                    <!-- Bandwidth -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Bandwidth</label>
                        <div class="flex items-center space-x-4">
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="bandwidth" id="bandwidthNarrow" value="narrow" checked
                                    class="w-4 h-4 text-primary focus:ring-primary cursor-pointer">
                                <span class="ml-2 text-sm">Narrow (12.5 kHz)</span>
                            </label>
                            <label class="inline-flex items-center cursor-pointer">
                                <input type="radio" name="bandwidth" id="bandwidthWide" value="wide"
                                    class="w-4 h-4 text-primary focus:ring-primary cursor-pointer">
                                <span class="ml-2 text-sm">Wide (25 kHz)</span>
                            </label>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Narrow for most amateur/FRS; Wide for GMRS main channels</p>
                    </div>

                    <!-- Serial Connection -->
                    <div class="border-t border-gray-300 dark:border-gray-600 pt-4">
                        <label class="block text-sm font-medium mb-2">Serial Connection</label>
                        <button type="button" onclick="connectResource()"
                            class="w-full p-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors">
                            <i class="fas fa-plug mr-2"></i>Connect to KV4P-HT
                        </button>
                        <div id="resourceConnectionInfo" class="text-sm mt-2 text-center">
                            <span class="text-gray-500">Status: Not Connected</span>
                        </div>
                    </div>

                    <!-- Delete Button (only shown when editing) -->
                    <div id="resourceDeleteSection" class="hidden border-t border-gray-200 dark:border-gray-700 pt-4 mt-4">
                        <button type="button" onclick="confirmDeleteResourceFromModal()"
                            class="w-full p-2 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-trash"></i>
                            Delete Resource
                        </button>
                    </div>

                    <div class="flex space-x-3 pt-4">
                        <button type="button" onclick="hideModal('resourceModal')"
                            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors">
                            Cancel
                        </button>
                        <button type="submit"
                            class="flex-1 p-2 bg-primary hover:bg-primary/80 text-white rounded-lg transition-colors">
                            Save Resource
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Add/Edit Page Modal -->
    <div id="pageModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="pageModalTitle" class="text-xl font-bold">Add Page</h2>
                    <button onclick="hideModal('pageModal')" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <form id="pageForm" onsubmit="savePage(event)" class="space-y-4">
                    <input type="hidden" id="editingPageId" value="">

                    <div>
                        <label class="block text-sm font-medium mb-2">Page Name</label>
                        <input type="text" id="pageName" required placeholder="e.g., Station 1"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-2">Page Type</label>
                        <select id="pageType" onchange="updatePageTypeFields()"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base">
                            <option value="dtmf">DTMF Page</option>
                            <option value="2tone">2-Tone Page</option>
                        </select>
                    </div>

                    <div id="dtmfDiv">
                        <label class="block text-sm font-medium mb-2">DTMF String</label>
                        <input type="text" id="dtmfString" placeholder="e.g., 123A*#"
                            class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base font-mono">
                        <p class="text-xs text-gray-500 mt-1">Valid: 0-9, A-D, *, #, comma (2s pause)</p>
                    </div>

                    <div id="twoToneDiv" class="hidden space-y-3">
                        <div>
                            <label class="block text-sm font-medium mb-2">First Tone (Hz)</label>
                            <input type="number" id="firstToneFreq" min="100" max="3000" step="0.1" placeholder="1000"
                                class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base font-mono">
                            <p class="text-xs text-gray-500 mt-1">Duration: 1 second</p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Second Tone (Hz)</label>
                            <input type="number" id="secondToneFreq" min="100" max="3000" step="0.1" placeholder="1500"
                                class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-base font-mono">
                            <p class="text-xs text-gray-500 mt-1">Duration: 3 seconds</p>
                        </div>
                    </div>

                    <div class="flex space-x-3 pt-4">
                        <button type="button" onclick="hideModal('pageModal')"
                            class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors">
                            Cancel
                        </button>
                        <button type="submit"
                            class="flex-1 p-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors">
                            Save Page
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <div class="p-6">
                <h3 class="text-lg font-semibold mb-4" id="confirmTitle">Confirm Action</h3>
                <p class="text-gray-600 dark:text-gray-400 mb-6" id="confirmMessage"></p>
                <div class="flex justify-end space-x-3">
                    <button id="confirmCancel"
                        class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded transition-colors">
                        Cancel
                    </button>
                    <button id="confirmOk"
                        class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded transition-colors">
                        Confirm
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div id="errorModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4">
            <div class="p-6">
                <div class="flex items-start gap-4">
                    <div class="flex-shrink-0 w-10 h-10 rounded-full bg-red-100 dark:bg-red-900 flex items-center justify-center">
                        <i class="fas fa-exclamation-triangle text-red-500 dark:text-red-400"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="text-lg font-semibold text-red-600 dark:text-red-400 mb-2" id="errorTitle">Error</h3>
                        <p class="text-gray-600 dark:text-gray-400" id="errorMessage"></p>
                    </div>
                </div>
                <div class="flex justify-end mt-6">
                    <button onclick="hideModal('errorModal')"
                        class="px-6 py-2 bg-primary hover:bg-primary/80 text-white rounded-lg transition-colors">
                        OK
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div id="successModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full mx-4">
            <div class="p-6">
                <div class="flex items-start gap-4">
                    <div class="flex-shrink-0 w-10 h-10 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center">
                        <i class="fas fa-check text-green-500 dark:text-green-400"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="text-lg font-semibold text-green-600 dark:text-green-400 mb-2" id="successTitle">Success</h3>
                        <p class="text-gray-600 dark:text-gray-400" id="successMessage"></p>
                    </div>
                </div>
                <div class="flex justify-end mt-6">
                    <button onclick="hideModal('successModal')"
                        class="px-6 py-2 bg-primary hover:bg-primary/80 text-white rounded-lg transition-colors">
                        OK
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Stack Light Modal -->
    <div id="stackLightModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold"><i class="fas fa-lightbulb mr-2 text-yellow-500"></i>Stack Light Settings</h2>
                    <button onclick="hideModal('stackLightModal')" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Connection Section -->
                <div class="mb-6">
                    <label class="block text-sm font-medium mb-2">Serial Connection</label>
                    <button type="button" onclick="connectStackLight()"
                        class="w-full p-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors">
                        <i class="fas fa-plug mr-2"></i>Connect to Stack Light
                    </button>
                    <div id="stackLightConnectionInfo" class="text-sm mt-2 text-center">
                        <span class="text-gray-500">Status: Not Connected</span>
                    </div>
                </div>

                <!-- Light Function Reference -->
                <div class="border-t border-gray-200 dark:border-gray-700 pt-4">
                    <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-4">
                        <i class="fas fa-info-circle mr-2"></i>Light Functions
                    </h3>
                    
                    <!-- Stack Light Visual -->
                    <div class="flex items-start space-x-4 mb-4">
                        <!-- Stack Light Image -->
                        <div class="flex flex-col items-center space-y-1">
                            <div class="w-12 h-12 rounded-full bg-red-500 shadow-lg shadow-red-500/50 flex items-center justify-center">
                                <i class="fas fa-circle text-red-300 text-xs"></i>
                            </div>
                            <div class="w-12 h-12 rounded-full bg-yellow-500 shadow-lg shadow-yellow-500/50 flex items-center justify-center">
                                <i class="fas fa-circle text-yellow-300 text-xs"></i>
                            </div>
                            <div class="w-12 h-12 rounded-full bg-green-500 shadow-lg shadow-green-500/50 flex items-center justify-center">
                                <i class="fas fa-circle text-green-300 text-xs"></i>
                            </div>
                            <div class="w-8 h-4 bg-gray-400 dark:bg-gray-600 rounded"></div>
                        </div>
                        
                        <!-- Function Descriptions -->
                        <div class="flex-1 space-y-3 text-sm">
                            <div class="p-2 bg-red-50 dark:bg-red-900/20 rounded-lg border-l-4 border-red-500">
                                <div class="font-semibold text-red-700 dark:text-red-400">Red Light</div>
                                <div class="text-gray-600 dark:text-gray-400 text-xs mt-1">
                                    <strong>Solid:</strong> Unacknowledged emergency alert<br>
                                    <strong>On during tone:</strong> Priority tone transmitting
                                </div>
                            </div>
                            <div class="p-2 bg-yellow-50 dark:bg-yellow-900/20 rounded-lg border-l-4 border-yellow-500">
                                <div class="font-semibold text-yellow-700 dark:text-yellow-400">Yellow Light</div>
                                <div class="text-gray-600 dark:text-gray-400 text-xs mt-1">
                                    <strong>Solid:</strong> Transmitting (voice, alert tone, 2-tone page, or DTMF page)
                                </div>
                            </div>
                            <div class="p-2 bg-green-50 dark:bg-green-900/20 rounded-lg border-l-4 border-green-500">
                                <div class="font-semibold text-green-700 dark:text-green-400">Green Light</div>
                                <div class="text-gray-600 dark:text-gray-400 text-xs mt-1">
                                    <strong>Solid:</strong> Receiving audio on any selected resource
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <p class="text-xs text-gray-500 mt-3">
                        <i class="fas fa-lightbulb mr-1"></i>
                        Multiple lights can be active simultaneously. The stack light will automatically sync with console activity.
                    </p>
                </div>

                <!-- Close Button -->
                <button onclick="hideModal('stackLightModal')" 
                    class="w-full p-3 bg-gray-500 hover:bg-gray-600 text-white rounded-lg font-medium transition-colors mt-4">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold"><i class="fas fa-question-circle mr-2 text-primary"></i>Help</h2>
                    <button onclick="hideModal('helpModal')" class="p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <div id="helpTopics" class="space-y-2">
                    <!-- Getting Started -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-getting-started')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Getting Started</span>
                            <i id="help-getting-started-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-getting-started" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Welcome to the Common Dispatch Console, a web-based radio dispatch interface designed for use with KV4P-HT radio hardware. This console allows you to monitor and transmit on multiple radio frequencies simultaneously, send pages, manage radio aliases, and respond to emergencies.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">To begin, add a resource by clicking the "+ Add Resource" button, configure the frequency and tone settings, then connect to your KV4P-HT device via the serial connection option in the resource editor. Once connected, you can monitor receive audio, transmit using push-to-talk controls, and utilize the full range of dispatch features.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The console stores your configuration locally in your browser, so your resources, pages, and settings will persist between sessions.</p>
                        </div>
                    </div>

                    <!-- KV4P-HT Hardware -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-hardware')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>KV4P-HT Hardware (VHF vs UHF)</span>
                            <i id="help-hardware-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-hardware" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The KV4P-HT comes in two hardware variants, each with a different radio module that determines which frequencies it can operate on:</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2"><strong>VHF Model (SA818-V):</strong> Operates on VHF frequencies from 134-174 MHz. Common uses include 2-meter amateur band (144-148 MHz), MURS, marine VHF, and VHF public safety.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2"><strong>UHF Model (SA818-U):</strong> Operates on UHF frequencies from 400-480 MHz. Common uses include 70cm amateur band (420-450 MHz), GMRS/FRS, and UHF public safety.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The console automatically detects which module type is installed when you connect. The status indicator on the resource card will show "VHF" or "UHF" after successful connection.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2"><strong>Important:</strong> If you configure a frequency that doesn't match the connected hardware (e.g., a UHF frequency on a VHF unit), the console will display an error and prevent transmission until the frequency is corrected.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">You can connect multiple KV4P-HT units to the same computer - for example, one VHF and one UHF unit to monitor and transmit on both bands simultaneously.</p>
                        </div>
                    </div>

                    <!-- Master Volume & Microphone -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-volume')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Master Volume & Microphone</span>
                            <i id="help-volume-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-volume" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The Master Volume slider (0-7) controls the overall output level for all audio played through the console, including receive audio from resources, alert tones, and system sounds. Level 7 is maximum volume; level 0 is muted.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The Microphone slider (0-7) controls the input gain for your microphone during transmissions. Level 6 is recommended for most setups. Adjust as needed to ensure your transmitted audio is clear without distortion.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The VU Meter below these controls provides visual feedback of audio levels. When idle, the meter is inactive. During receive, it displays a speaker icon and shows the averaged audio level from all selected resources currently receiving. During transmit, it displays a microphone icon and shows your outgoing audio level.</p>
                        </div>
                    </div>

                    <!-- Muting -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-muting')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Muting</span>
                            <i id="help-muting-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-muting" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The Mute button temporarily silences audio from unselected resources while allowing selected resources to continue playing. This is useful when you need to focus on specific channels without losing awareness of activity on others.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Muting automatically disables after 15 seconds to prevent accidentally missing important transmissions. The button displays red when muting is active.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Note: Selected resources are never muted, ensuring you always hear priority traffic.</p>
                        </div>
                    </div>

                    <!-- General Transmit -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-general-tx')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>General Transmit (PTT)</span>
                            <i id="help-general-tx-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-general-tx" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The General Transmit button (red lightning bolt) is your primary push-to-talk control. Press and hold to transmit on all selected and connected resources simultaneously. Release to end the transmission.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Before transmitting, you will hear a brief talk permit tone (three short beeps) confirming the transmission has begun. If no resources are available for transmission, you will hear a denied tone (low buzzer).</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">If some selected resources are busy receiving while others are available, you will hear a denied tone followed by a talk permit tone. Transmission will begin on available resources, and busy resources will automatically join the transmission when they stop receiving.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">You can also use a keyboard key for PTT. The default key is Space, but this can be customized in Settings. Keyboard PTT is disabled when any settings window or dialog is open.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">During transmission, unselected resources are automatically muted to prevent feedback and allow you to focus on your outgoing message.</p>
                        </div>
                    </div>

                    <!-- Alert Tones -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-alert-tones')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Alert Tones</span>
                            <i id="help-alert-tones-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-alert-tones" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The two Alert Tone buttons (labeled 1 and 2) allow you to transmit attention-getting tones over the air while holding the button.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Alert Tone 1 produces a continuous 1000 Hz tone, commonly used for general attention signals.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Alert Tone 2 produces an alternating two-tone pattern (1500 Hz / 900 Hz), useful for urgent attention or different alert classifications.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Pressing either alert button will automatically begin transmission on selected resources if not already transmitting. Release the button to stop the tone. The transmission continues until you release, allowing you to follow the alert tone with a voice message if desired.</p>
                        </div>
                    </div>

                    <!-- Paging -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-paging')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Paging</span>
                            <i id="help-paging-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-paging" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The Paging button (pager icon) transmits all stacked pages in sequence. Pages are stacked by long-pressing on a page card in the Pages section. Stacked pages display a green checkmark.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">To transmit stacked pages, click the Paging button. The console will key up on all selected resources and transmit each stacked page with a brief pause between them. After transmission, the stack is automatically cleared.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">For immediate single-page transmission without stacking, simply single-click on any page card. This will instantly transmit that page on all selected resources.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2"><strong>Canceling:</strong> While paging is in progress, the button turns red and displays "Cancel". Click it again to immediately stop the current page and clear any remaining pages in the stack. You can also interrupt paging by pressing General Transmit or Instant Transmit.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">If no pages are stacked when clicking the Paging button, or no resources are available, you will hear a denied tone.</p>
                        </div>
                    </div>

                    <!-- Resources Overview -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-resources')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Resources Overview</span>
                            <i id="help-resources-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-resources" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Resources represent individual radio channels or frequencies. Each resource corresponds to one KV4P-HT device connection and can be configured with its own frequency, tone settings, and transmit power.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Resource cards display the channel name, frequency, tone type, and connection status. The colored border indicates selection state: purple for selected, gray for unselected. The status row shows connection state, RX/TX indicator, RSSI signal bars, and caller ID.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Caller ID displays in real-time as DTMF digits are received, updating progressively until the full ID is decoded. If alias decoding is enabled and a match is found, the friendly name replaces the digits. After transmission ends, the caller ID fades over 10 seconds.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Click anywhere on the resource information area to toggle selection. Selected resources are routed to your left audio channel; unselected resources are routed to your right channel. This stereo separation helps you distinguish between priority and background traffic.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Each resource has a volume slider (0-7) to adjust its individual playback level. Note that activity log recordings are always captured at full volume regardless of this setting.</p>
                        </div>
                    </div>

                    <!-- Adding & Editing Resources -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-add-resource')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Adding & Editing Resources</span>
                            <i id="help-add-resource-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-add-resource" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Click "+ Add Resource" to create a new resource. In the resource editor, configure:</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2"><strong>Resource Name:</strong> A descriptive label for the channel (e.g., "Fire Dispatch").</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Operation Mode:</strong> Simplex uses the same frequency for transmit and receive. Half-Duplex allows separate transmit and receive frequencies for repeater operation.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Frequencies:</strong> Enter the receive frequency, and for half-duplex, the separate transmit frequency. Valid ranges are VHF (134-174 MHz) and UHF (400-480 MHz).</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Tone Type:</strong> CSQ (Carrier Squelch) opens on any signal. CTCSS requires a matching sub-audible tone to open squelch.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Squelch Sensitivity:</strong> Adjusts how strong a signal must be to open squelch (0 = most sensitive, 8 = least sensitive).</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Transmit Power:</strong> High or Low power output.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Bandwidth:</strong> Narrow (12.5 kHz) for most amateur and FRS channels. Wide (25 kHz) for GMRS main channels. Using the wrong bandwidth may cause audio distortion or reduced range.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Important: When adding a new resource, you must save it first, then re-open the resource editor by clicking the edit button, and then click "Connect to KV4P-HT" to establish the serial connection.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">To edit an existing resource, click the pencil icon on the resource card. The Delete Resource option is available at the bottom of the edit dialog.</p>
                        </div>
                    </div>

                    <!-- Connecting to KV4P-HT -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-connect')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Connecting to KV4P-HT</span>
                            <i id="help-connect-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-connect" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Each resource requires a connection to a KV4P-HT device via Web Serial API. To connect:</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">1. Open the resource editor by clicking the pencil icon on the resource card</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">2. Click "Connect to KV4P-HT"</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">3. Select your KV4P-HT device from the browser's serial port picker</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">4. Wait for the handshake to complete</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">During connection, the console performs a handshake with the device to determine its radio module type (VHF or UHF). The status indicator will briefly show "Init..." (yellow) during this process, then change to "VHF" or "UHF" (green) when ready.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">If the configured frequency doesn't match the detected radio module, an error dialog will appear. You must edit the resource and set an appropriate frequency before transmission will work.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">If a device is disconnected unexpectedly (USB unplugged, etc.), the status will change to "Disconnected" (red) and you'll hear a denied tone. Simply reconnect the device and use the Connect button again.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Note: Web Serial API requires a Chromium-based browser (Chrome, Edge, Opera) and may require HTTPS or localhost. Each resource needs its own dedicated KV4P-HT device.</p>
                        </div>
                    </div>

                    <!-- Instant Transmit -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-instant-tx')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Instant Transmit</span>
                            <i id="help-instant-tx-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-instant-tx" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Each resource card has a red lightning bolt button on the left side. This is the Instant Transmit button, allowing you to transmit on that specific resource only, regardless of selection state.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Press and hold the Instant Transmit button to key up on that single resource. Release to end transmission. This is useful when you need to respond on a specific channel without affecting or transmitting on other selected resources.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Instant Transmit will override a resource that is currently receiving, immediately stopping the receive and beginning transmission. This differs from General Transmit, which will not interrupt receiving resources.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The talk permit and denied tones function the same as General Transmit.</p>
                        </div>
                    </div>

                    <!-- Priority Tone -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-priority')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Priority Tone</span>
                            <i id="help-priority-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-priority" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The tower icon with a music note indicates the Priority function. When enabled (purple), the resource will automatically transmit a 675 Hz priority tone for 750ms every 10 seconds.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Priority tones are commonly used to mark a channel as active or to maintain repeater timeout timers during extended incidents. The tone is transmitted over the air on that resource only.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">If the resource is actively receiving when a priority tone is scheduled, the tone will be queued and transmitted immediately when the receive ends, ensuring the tone doesn't interfere with incoming traffic.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">If you are transmitting on any resource when a priority tone is scheduled, the tone will be queued and transmitted after your transmission ends. This prevents priority tones from bleeding into voice transmissions on other channels.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Click the priority button to toggle this feature on or off.</p>
                        </div>
                    </div>

                    <!-- Patch -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-patch')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Patch (Cross-Connect)</span>
                            <i id="help-patch-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-patch" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The link icon enables Patch mode for a resource. When exactly two resources have Patch enabled (displayed in yellow), audio received on one resource is automatically retransmitted on the other, creating a cross-connect or "patch" between the two channels.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">This is useful for connecting units on different frequencies or linking a local channel to a mutual aid frequency. The patch operates in both directions: traffic on either channel is heard on both and rebroadcast to the other.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">A maximum of two resources can be patched together at one time. To disable patching, click the patch button on either resource to remove it from the patch group.</p>
                        </div>
                    </div>

                    <!-- Activity Log -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-activity-log')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Activity Log</span>
                            <i id="help-activity-log-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-activity-log" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Each resource maintains an activity log of recent transmissions. Click the "Activity Log" bar at the bottom of a resource card to expand or collapse the log view. Multiple activity logs can be open simultaneously.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The log displays the most recent receive (RX) and transmit (TX) events with timestamps, duration, and caller ID when available. Each entry has controls to:</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Play:</strong> Listen to the recorded audio</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400"><strong>Download:</strong> Save the recording as a WAV file</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400"><strong>Delete:</strong> Remove the recording from the log</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Recordings are always captured at full volume regardless of the resource volume slider setting, ensuring important transmissions are clearly audible when played back.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Recordings are stored in memory and will be lost when you close or refresh the browser. Download important recordings to preserve them. Each resource retains up to 20 recordings, with oldest entries automatically removed.</p>
                        </div>
                    </div>

                    <!-- Pages Overview -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-pages')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Pages Overview</span>
                            <i id="help-pages-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-pages" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Pages are pre-configured tone sequences used to alert or activate remote equipment such as pagers, station alerting systems, or tone-activated devices. The console supports two page types: DTMF and 2-Tone.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Page cards display the page name and type. Single-click a page card to immediately transmit that page on all selected resources. Long-press (hold for 0.5 seconds) to add the page to the transmission stack without sending immediately.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Stacked pages display a green border and checkmark. Use the Paging button in Master Controls to transmit all stacked pages in sequence.</p>
                        </div>
                    </div>

                    <!-- DTMF Pages -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-dtmf-pages')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>DTMF Pages</span>
                            <i id="help-dtmf-pages-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-dtmf-pages" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">DTMF (Dual-Tone Multi-Frequency) pages transmit a sequence of touch-tone digits. These are commonly used for pager systems, remote base control, and autopatch access.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">When creating a DTMF page, enter the digit string using: 0-9, A-D, *, and #. Use a comma (,) to insert a 2-second pause in the sequence.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Example: "123,456" would send "123", pause for 2 seconds, then send "456".</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Each digit is transmitted for 100ms with a 50ms gap between digits.</p>
                        </div>
                    </div>

                    <!-- 2-Tone Pages -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-2tone-pages')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>2-Tone Pages</span>
                            <i id="help-2tone-pages-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-2tone-pages" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">2-Tone pages transmit a two-frequency sequential tone pattern, commonly used for fire station alerting and paging systems.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">When creating a 2-Tone page, specify the First Tone and Second Tone frequencies in Hz. Valid frequencies range from 100 Hz to 3000 Hz.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The first tone transmits for 1 second, immediately followed by the second tone for 3 seconds, matching standard fire alerting timing.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Consult your paging system documentation for the specific tone frequencies assigned to each station or unit.</p>
                        </div>
                    </div>

                    <!-- Radio Aliases -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-aliases')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Radio Aliases</span>
                            <i id="help-aliases-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-aliases" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Radio Aliases allow you to assign friendly names to DTMF radio IDs. When a transmission includes a DTMF ID (sent at the start or end of a transmission), the console will decode it and display the corresponding alias instead of the raw digits.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Access the Alias Manager by clicking the address book icon in the header. Here you can add, edit, and delete aliases. Each alias maps a DTMF ID string (1-10 characters) to a display name.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Alias decoding can be enabled or disabled in the Alias Manager settings. When enabled, decoded aliases appear in the RX indicator on resource cards and in activity log entries.</p>
                        </div>
                    </div>

                    <!-- Emergency Alerts -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-emergency')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Emergency Alerts</span>
                            <i id="help-emergency-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-emergency" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The console monitors all incoming transmissions for emergency activations by detecting a specific DTMF sequence. When detected, the console immediately triggers an emergency alert with audible and visual warnings—no need to wait for the transmission to end.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Configure the emergency trigger DTMF string in the Emergency settings (accessible via the warning triangle icon in the header). For example, setting "911" will trigger an alert whenever that sequence is received. The trigger is detected even when embedded in longer DTMF strings (e.g., "101911" triggers on "911").</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">During an active emergency:</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">• An audible emergency tone plays continuously</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">• The emergency button flashes red with a badge count</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">• The originating resource card pulses with a red border</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">• The resource is forced to full volume regardless of other settings</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">• Caller ID displays the unit identifier (with emergency trigger stripped)</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Click "Acknowledge All" in the Emergency panel to silence the alert and return to normal operation. Emergency history is preserved for review.</p>
                        </div>
                    </div>

                    <!-- Settings -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-settings')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Settings</span>
                            <i id="help-settings-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-settings" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">Access Settings via the gear icon in the header. Available options include:</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2"><strong>Console Name:</strong> Customize the title displayed in the header.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Theme:</strong> Choose between Light, Dark, or System Default appearance.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Clock Display:</strong> Show a real-time clock in the header bar. Choose between 12-hour and 24-hour format.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Selected/Unselected Volume:</strong> Set default volume levels (0-7) for selected and unselected resources.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Show RSSI:</strong> Toggle signal strength meter display on resource cards.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>PTT Key:</strong> Assign a custom keyboard key for General Transmit push-to-talk.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Console ID:</strong> When enabled, automatically transmits a DTMF identification string at the start and/or end of your transmissions. Configure the ID string and timing preference.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2"><strong>Configuration Management:</strong></p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">• <strong>Export:</strong> Download your entire configuration (settings, resources, aliases, pages) as a JSON file for backup or transfer to another device.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">• <strong>Import:</strong> Load a previously exported configuration file to restore your setup.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">• <strong>Clear:</strong> Reset all settings and data to factory defaults.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Settings are automatically saved to your browser's local storage.</p>
                        </div>
                    </div>

                    <!-- Keyboard Shortcuts -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-keyboard')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Keyboard Shortcuts</span>
                            <i id="help-keyboard-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-keyboard" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400"><strong>Space</strong> (or custom key): Push-to-talk for General Transmit. Press and hold to transmit on all selected resources.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">Keyboard PTT is automatically disabled when any settings window or dialog is open, preventing accidental transmissions while configuring the console.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">The PTT key can be customized in Settings. Click "Click to Set Key" and press your desired key to assign it.</p>
                        </div>
                    </div>

                    <!-- Stack Light -->
                    <div class="help-topic border border-gray-200 dark:border-gray-700 rounded-lg">
                        <button onclick="toggleHelpTopic('help-stacklight')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg">
                            <span>Stack Light (AndonStack)</span>
                            <i id="help-stacklight-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-stacklight" class="hidden px-3 pb-3">
                            <p class="text-sm text-gray-600 dark:text-gray-400">The optional AndonStack is a physical stack light that provides visual status indication for the dispatch console. It uses an ESP32-C3 microcontroller with WS2812B NeoPixel LED rings.</p>
                            
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-3"><strong>Light Functions:</strong></p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Green (solid):</strong> Receiving audio on any selected resource.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Yellow (solid):</strong> Transmitting - voice, alert tone, 2-tone page, or DTMF page on any resource.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Red (solid):</strong> Unacknowledged emergency alert active.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1"><strong>Red (on during tone):</strong> Priority tone actively transmitting. Light turns on only while the tone audio is playing.</p>
                            
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-3"><strong>Setup:</strong></p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">1. Enable "Stack Light" in Settings.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">2. Click the Stack Light Settings button that appears.</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">3. Click "Connect to Stack Light" and select the ESP32-C3 serial port.</p>
                            
                            <p class="text-sm text-gray-600 dark:text-gray-400 mt-3"><strong>Note:</strong> Multiple lights can be active simultaneously (e.g., green + yellow when receiving on one resource while transmitting on another).</p>
                        </div>
                    </div>

                    <!-- About -->
                    <div class="help-topic border border-primary/30 rounded-lg bg-primary/5">
                        <button onclick="toggleHelpTopic('help-about')" class="w-full flex justify-between items-center p-3 text-left font-medium hover:bg-primary/10 rounded-lg">
                            <span><i class="fas fa-info-circle mr-2 text-primary"></i>About</span>
                            <i id="help-about-icon" class="fas fa-caret-right text-gray-400"></i>
                        </button>
                        <div id="help-about" class="hidden px-3 pb-3">
                            <div class="text-center mb-4">
                                <h3 class="text-lg font-bold text-primary">Common Dispatch Console</h3>
                                <p class="text-sm text-gray-500">Version 2.4</p>
                            </div>
                            
                            <div class="space-y-3 text-sm text-gray-600 dark:text-gray-400">
                                <div>
                                    <h4 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">Copyright</h4>
                                    <p><i class="fas fa-copyright mr-2 text-primary"></i>2025 Brandon Cooper</p>
                                </div>
                                
                                <div>
                                    <h4 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">License</h4>
                                    <p class="mb-1"><i class="fas fa-balance-scale mr-2 text-green-500"></i>GNU General Public License v3.0 (GPL-3.0)</p>
                                    <p class="text-xs text-gray-500 ml-6">
                                        This is free software. You may redistribute and/or modify it under the terms of the GPL.
                                        <a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank" class="text-primary hover:underline ml-1">
                                            Read full license <i class="fas fa-external-link-alt text-xs"></i>
                                        </a>
                                    </p>
                                </div>
                                
                                <div>
                                    <h4 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">Hardware Contributors</h4>
                                    <p><i class="fas fa-radio mr-2 text-green-500"></i><strong>Vance Vagell</strong> - KV4P-HT Radio Project Creator</p>
                                    <p><i class="fas fa-microchip mr-2 text-blue-500"></i><strong>SmittyHalibut</strong> - Electronics Design</p>
                                </div>
                                
                                <div>
                                    <h4 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">AI Development Assistants</h4>
                                    <p><i class="fas fa-robot mr-2 text-purple-500"></i><strong>Claude</strong> (Anthropic) - Primary Development</p>
                                    <p><i class="fas fa-robot mr-2 text-blue-400"></i><strong>Gemini</strong> (Google) - Additional Assistance</p>
                                    <p><i class="fas fa-robot mr-2 text-orange-500"></i><strong>Poe</strong> - Additional Assistance</p>
                                </div>
                                
                                <div>
                                    <h4 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">Supported Hardware</h4>
                                    <ul class="list-disc list-inside space-y-1 ml-2">
                                        <li><strong>KV4P-HT VHF</strong> - SA818-V module (134-174 MHz)</li>
                                        <li><strong>KV4P-HT UHF</strong> - SA818-U module (400-480 MHz)</li>
                                    </ul>
                                </div>
                                
                                <div>
                                    <h4 class="font-semibold text-gray-700 dark:text-gray-300 mb-1">Open Source Libraries</h4>
                                    <ul class="list-disc list-inside space-y-1 ml-2">
                                        <li><strong>Tailwind CSS</strong> - Utility-first CSS framework</li>
                                        <li><strong>Font Awesome</strong> - Icon library</li>
                                        <li><strong>Web Serial API</strong> - Browser serial communication</li>
                                        <li><strong>WebCodecs API</strong> - Opus audio encoding/decoding</li>
                                        <li><strong>Goertzel Algorithm</strong> - DTMF tone detection</li>
                                    </ul>
                                </div>
                                
                                <div class="pt-2 border-t border-gray-200 dark:border-gray-700">
                                    <p class="text-xs text-center text-gray-500">
                                        <i class="fas fa-code mr-1"></i>
                                        Built with web technologies for use with KV4P-HT amateur radio hardware.
                                        <br>
                                        <a href="https://github.com/VanceVagell/kv4p-ht" target="_blank" class="text-primary hover:underline">
                                            <i class="fab fa-github mr-1"></i>KV4P-HT on GitHub
                                        </a>
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ============================================================================
    // COMMON DISPATCH CONSOLE v2.4
    // ============================================================================

    // === SERIAL PROTOCOL CONSTANTS (Verified from kv4p-ht source) ===
    const COMMAND_DELIMITER = [0xDE, 0xAD, 0xBE, 0xEF];
    
    // Host → Device Commands
    const COMMAND_HOST_PTT_DOWN = 0x01;
    const COMMAND_HOST_PTT_UP = 0x02;
    const COMMAND_HOST_GROUP = 0x03;  // Renamed from TUNE - binary format
    const COMMAND_HOST_FILTERS = 0x04;
    const COMMAND_HOST_STOP = 0x05;
    const COMMAND_HOST_CONFIG = 0x06;
    const COMMAND_HOST_TX_AUDIO = 0x07;
    const COMMAND_HOST_HL = 0x08;     // High/Low power
    const COMMAND_HOST_RSSI = 0x09;   // Enable RSSI reports
    
    // Device → Host Commands
    const COMMAND_HELLO = 0x06;        // ESP32 ready/rebooted
    const COMMAND_RX_AUDIO = 0x07;
    const COMMAND_VERSION = 0x08;
    const COMMAND_WINDOW_UPDATE = 0x09; // Flow control
    const COMMAND_PHYS_PTT_DOWN = 0x44;
    const COMMAND_SMETER_REPORT = 0x53;
    const COMMAND_PHYS_PTT_UP = 0x55;

    // RF Module Types (from ESP32 firmware)
    const RF_MODULE_VHF = 0;
    const RF_MODULE_UHF = 1;

    // === CTCSS TONE INDEX LOOKUP (Verified from ToneHelper.java) ===
    const CTCSS_TONES = [
        "None",   // Index 0 = CSQ (no tone)
        "67.0",   // Index 1
        "71.9",   // Index 2
        "74.4",   // Index 3
        "77.0",   // Index 4
        "79.7",   // Index 5
        "82.5",   // Index 6
        "85.4",   // Index 7
        "88.5",   // Index 8
        "91.5",   // Index 9
        "94.8",   // Index 10
        "97.4",   // Index 11
        "100.0",  // Index 12
        "103.5",  // Index 13
        "107.2",  // Index 14
        "110.9",  // Index 15
        "114.8",  // Index 16
        "118.8",  // Index 17
        "123.0",  // Index 18
        "127.3",  // Index 19
        "131.8",  // Index 20
        "136.5",  // Index 21
        "141.3",  // Index 22
        "146.2",  // Index 23
        "151.4",  // Index 24
        "156.7",  // Index 25
        "162.2",  // Index 26
        "167.9",  // Index 27
        "173.8",  // Index 28
        "179.9",  // Index 29
        "186.2",  // Index 30
        "192.8",  // Index 31
        "203.5",  // Index 32
        "210.7",  // Index 33
        "218.1",  // Index 34
        "225.7",  // Index 35
        "233.6",  // Index 36
        "241.8",  // Index 37
        "250.3"   // Index 38
    ];

    function getCtcssIndex(toneString) {
        if (!toneString || toneString === 'CSQ' || toneString === 'None') return 0;
        const idx = CTCSS_TONES.indexOf(toneString);
        return idx >= 0 ? idx : 0;
    }

    // === DTMF FREQUENCY TABLES ===
    const DTMF_FREQS = {
        '1': [697, 1209], '2': [697, 1336], '3': [697, 1477], 'A': [697, 1633],
        '4': [770, 1209], '5': [770, 1336], '6': [770, 1477], 'B': [770, 1633],
        '7': [852, 1209], '8': [852, 1336], '9': [852, 1477], 'C': [852, 1633],
        '*': [941, 1209], '0': [941, 1336], '#': [941, 1477], 'D': [941, 1633]
    };

    // Goertzel detection frequencies
    const DTMF_LOW_FREQS = [697, 770, 852, 941];
    const DTMF_HIGH_FREQS = [1209, 1336, 1477, 1633];
    const DTMF_CHARS = [
        ['1', '2', '3', 'A'],
        ['4', '5', '6', 'B'],
        ['7', '8', '9', 'C'],
        ['*', '0', '#', 'D']
    ];

    // === GLOBAL STATE VARIABLES ===

    // Resources & Pages
    let resources = [];
    let nextResourceId = 1;
    let pages = [];
    let nextPageId = 1;

    // Resource UI State
    let expandedResources = new Set();

    // Audio Context & Nodes
    let audioContext = null;
    let masterGainNode = null;
    let micStream = null;
    let micSource = null;
    let micGainNode = null;
    let resourceAudioNodes = new Map();

    // Opus Encoder/Decoder (libopusjs - 48kHz, mono, 20ms frames = 1920 samples)
    let opusEncoder = null;
    let opusDecoder = null;  // Global decoder (deprecated - use per-resource decoders)
    let resourceOpusDecoders = new Map();  // Per-resource Opus decoders to fix multi-resource audio
    const OPUS_SAMPLE_RATE = 48000;
    const OPUS_FRAME_SIZE = 960;   // 20ms at 48kHz (matching v1/app)
    const OPUS_BITRATE = 24000;    // 24kbps - good for voice
    let pcmTxBuffer = [];          // Buffer for accumulating TX samples

    // TX Audio Merger (combines mic + generated tones)
    let txMergerNode = null;
    let txProcessorNode = null;

    // VU Meter state
    let vuMeterMode = 'idle';  // 'idle', 'rx', 'tx'
    let vuMeterAnimationFrame = null;

    // Volume Settings (0-7 scale)
    let masterVolume = 5;
    let micVolume = 6;
    let selectedVolume = 7;
    let unselectedVolume = 5;

    // Clock Display
    let showClock = false;
    let clockFormat = '12';  // '12' or '24'
    let clockInterval = null;

    // Muting
    let isMuted = false;
    let muteTimeout = null;

    // Theme & Console
    let currentTheme = 'system';
    let consoleName = "Common Dispatch";
    let showRssi = true;

    // Stack Light
    let stackLightEnabled = false;
    let stackLightPort = null;
    let stackLightWriter = null;
    let stackLightReader = null;
    let stackLightConnected = false;
    let stackLightPollInterval = null;
    let priorityTonePlaying = false;
    const STACK_LIGHT_CMD_STATUS_REQUEST = 0xFF;
    const STACK_LIGHT_CMD_STATUS_RESPONSE = 0xFE;
    const STACK_LIGHT_OFF = 0x00;
    const STACK_LIGHT_SOLID = 0x01;
    const STACK_LIGHT_BLINK = 0x02;

    // Console ID
    let consoleIdEnabled = false;
    let consoleIdString = '';
    let consoleIdTiming = 'end';

    // PTT
    let pttKey = ' ';
    let isBindingKey = false;
    let isPttDown = false;

    // Transmit State
    let activeTxIds = [];
    let txPacketCount = 0;
    let pendingTxIds = [];
    let isTransmittingPages = false;

    // Patching
    let patchedResources = [];
    let rebroadcastState = { sourceId: null, targetId: null };

    // Priority Tone
    let priorityIntervals = new Map();
    let priorityQueued = new Map();

    // Paging
    let stackedPages = [];
    let pagePressTimer = null;
    let isLongPress = false;
    let activePagingOscillators = []; // Track oscillators for cancellation
    let pagingCancelled = false; // Flag to exit loops on cancel

    // Alert Tones
    let alertTone1Playing = false;
    let alertTone2Playing = false;
    let alertTone1Oscillator = null;
    let alertTone2Interval = null;

    // Radio Aliases
    let radioAliases = [];
    let nextAliasId = 1;
    let selectedAliasIds = [];
    let aliasDecodingEnabled = true;

    // Emergency System
    let emergencyEvents = [];
    let nextEmergencyId = 1;
    let emergencyEnabled = true;
    let emergencyTriggerDtmf = '';
    let activeEmergencyResourceIds = new Set();
    let emergencyToneNodes = [];
    let emergencyToneScheduler = null;
    let emergencyToneStartTime = 0;

    // Recording
    let activeRecorders = new Map();

    // DTMF Decoders (one per resource)
    let resourceDtmfDecoders = new Map();

    // Modal tracking for PTT keybind
    const modalIds = ['settingsModal', 'aliasesModal', 'aliasEditModal', 'emergencyModal', 'resourceModal', 'pageModal', 'confirmModal', 'errorModal', 'successModal', 'helpModal', 'stackLightModal'];

    // ============================================================================
    // DTMF DECODER CLASS (Goertzel Algorithm)
    // ============================================================================

    class DTMFDecoder {
        constructor(sampleRate = 44100) {
            this.sampleRate = sampleRate;
            // Use 20ms block size for detection
            this.blockSize = Math.floor(sampleRate * 0.02); // 20ms blocks
            this.threshold = 0.018; // Balanced threshold - catches real DTMF while reducing voice false positives
            this.detectedDigits = '';
            this.lastConfirmedDigit = null; // The last digit we accepted
            this.lastDigitTime = 0;
            this.startWindowDigits = '';
            this.endWindowDigits = '';
            this.isCapturingStart = true;
            this.startWindowTimeout = null;
            this.transmissionStartTime = 0;
            // Sample buffer for accumulation
            this.sampleBuffer = new Float32Array(0);
            this.consecutiveDetections = 0;
            this.lastDetectedDigit = null; // Currently detected digit (for consecutive tracking)
            this.requiredConsecutive = 3; // Require 3 consecutive detections to confirm
            this.silenceCount = 0; // Count of consecutive blocks with no detection
            this.requiredSilence = 2; // Require 2 blocks of silence before same digit can repeat
            this.digitLocked = false; // Lock detection until silence is seen
            this.debugMode = true; // Enable magnitude logging
            this.debugCounter = 0;
            
            // Emergency detection - immediate alerting
            this.resourceId = null; // Set when decoder is created for a resource
            this.onEmergencyDetected = null; // Callback function(resourceId, callerId)
            this.onDigitDetected = null; // Callback function(resourceId, allDigits, resolvedCallerId) - for real-time display
            this.emergencyTriggeredThisSession = false; // Prevent duplicate alerts per session
        }

        // Goertzel algorithm for single frequency detection
        goertzel(samples, targetFreq) {
            const k = Math.floor(0.5 + (this.blockSize * targetFreq) / this.sampleRate);
            const w = (2 * Math.PI * k) / this.blockSize;
            const cosine = Math.cos(w);
            const coeff = 2 * cosine;

            let s0 = 0, s1 = 0, s2 = 0;
            for (let i = 0; i < samples.length; i++) {
                s0 = samples[i] + coeff * s1 - s2;
                s2 = s1;
                s1 = s0;
            }

            const power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
            return Math.sqrt(Math.abs(power)) / this.blockSize;
        }

        // Detect DTMF digit from audio samples
        detectDTMF(samples) {
            if (samples.length < this.blockSize) return null;

            // Use only blockSize samples
            const block = samples.slice(0, this.blockSize);

            const lowMagnitudes = DTMF_LOW_FREQS.map(f => this.goertzel(block, f));
            const highMagnitudes = DTMF_HIGH_FREQS.map(f => this.goertzel(block, f));

            // Find max in each group
            let maxLowIdx = 0, maxLowVal = lowMagnitudes[0];
            let maxHighIdx = 0, maxHighVal = highMagnitudes[0];

            for (let i = 1; i < 4; i++) {
                if (lowMagnitudes[i] > maxLowVal) { maxLowVal = lowMagnitudes[i]; maxLowIdx = i; }
                if (highMagnitudes[i] > maxHighVal) { maxHighVal = highMagnitudes[i]; maxHighIdx = i; }
            }

            // Calculate average magnitudes for comparison
            const avgLow = lowMagnitudes.reduce((a, b) => a + b, 0) / 4;
            const avgHigh = highMagnitudes.reduce((a, b) => a + b, 0) / 4;

            // Debug logging every 50 blocks to see what frequencies are being detected
            this.debugCounter++;
            if (this.debugMode && this.debugCounter % 50 === 0 && (maxLowVal > 0.01 || maxHighVal > 0.01)) {
                console.log(`DTMF magnitudes - Low: [${lowMagnitudes.map(m => m.toFixed(4)).join(', ')}] High: [${highMagnitudes.map(m => m.toFixed(4)).join(', ')}]`);
                console.log(`  Max: low[${maxLowIdx}]=${maxLowVal.toFixed(4)} (${DTMF_LOW_FREQS[maxLowIdx]}Hz), high[${maxHighIdx}]=${maxHighVal.toFixed(4)} (${DTMF_HIGH_FREQS[maxHighIdx]}Hz)`);
            }

            // Thresholds for detection
            const lowThreshold = this.threshold;
            const highThreshold = this.threshold * 0.8; // Lower for high frequencies (they attenuate more in radio)
            
            // Require minimum combined magnitude to avoid false positives from noise
            const combinedMagnitude = maxLowVal + maxHighVal;
            const minCombinedMagnitude = 0.07; // Balanced value
            
            // "Twist" check: DTMF tones should have relatively balanced energy between low and high
            // Voice harmonics tend to have unbalanced energy (one much stronger than other)
            // Allow up to 5:1 ratio (more lenient for radio audio quality variations)
            const twistRatio = Math.max(maxLowVal, maxHighVal) / Math.min(maxLowVal, maxHighVal);
            const maxTwistRatio = 5.0;
            
            // "Peak prominence" check: ensure the detected frequencies stand out from others
            // Sort magnitudes to find second-highest in each group
            const sortedLow = [...lowMagnitudes].sort((a, b) => b - a);
            const sortedHigh = [...highMagnitudes].sort((a, b) => b - a);
            const lowPeakRatio = sortedLow[0] / (sortedLow[1] + 0.001); // How much does peak stand out
            const highPeakRatio = sortedHigh[0] / (sortedHigh[1] + 0.001);
            const minPeakRatio = 1.5; // Peak should be at least 1.5x the second highest (more lenient)
            
            if (maxLowVal > lowThreshold && maxHighVal > highThreshold &&
                maxLowVal > avgLow * 1.5 && maxHighVal > avgHigh * 1.5 &&
                combinedMagnitude > minCombinedMagnitude &&
                twistRatio < maxTwistRatio &&
                lowPeakRatio > minPeakRatio && highPeakRatio > minPeakRatio) {
                return DTMF_CHARS[maxLowIdx][maxHighIdx];
            }
            return null;
        }

        // Process incoming audio and return detected digit (if any)
        processAudio(samples) {
            // Accumulate samples
            const newBuffer = new Float32Array(this.sampleBuffer.length + samples.length);
            newBuffer.set(this.sampleBuffer);
            newBuffer.set(samples, this.sampleBuffer.length);
            this.sampleBuffer = newBuffer;
            
            // Process all complete blocks
            let detectedDigit = null;
            while (this.sampleBuffer.length >= this.blockSize) {
                const block = this.sampleBuffer.slice(0, this.blockSize);
                // Use 50% overlap for better detection
                this.sampleBuffer = this.sampleBuffer.slice(Math.floor(this.blockSize / 2));
                
                const digit = this.detectDTMF(block);
                
                if (digit) {
                    // Reset silence counter - we're hearing a tone
                    this.silenceCount = 0;
                    
                    // Track consecutive detections of same digit
                    if (digit === this.lastDetectedDigit) {
                        this.consecutiveDetections++;
                    } else {
                        this.consecutiveDetections = 1;
                        this.lastDetectedDigit = digit;
                    }
                    
                    // Accept digit if:
                    // 1. We have enough consecutive detections (filters noise)
                    // 2. Detection is not locked (we've seen silence since last digit)
                    if (this.consecutiveDetections >= this.requiredConsecutive && !this.digitLocked) {
                        this.detectedDigits += digit;
                        this.lastConfirmedDigit = digit;
                        this.lastDigitTime = Date.now();
                        this.digitLocked = true; // Lock until we see silence
                        detectedDigit = digit;
                        
                        // Capture for start/end windows
                        if (this.isCapturingStart) {
                            this.startWindowDigits += digit;
                        }
                        this.endWindowDigits += digit;
                        // Keep end window limited to recent digits
                        if (this.endWindowDigits.length > 10) {
                            this.endWindowDigits = this.endWindowDigits.slice(-10);
                        }
                        
                        console.log(`DTMF detected: ${digit} (start: ${this.startWindowDigits}, end: ${this.endWindowDigits})`);
                        
                        // IMMEDIATE EMERGENCY CHECK - alert as soon as trigger sequence is detected
                        this.checkImmediateEmergency();
                        
                        // REAL-TIME CALLER ID UPDATE - update display as digits are detected
                        if (this.onDigitDetected) {
                            this.onDigitDetected(this.resourceId, this.detectedDigits);
                        }
                    }
                } else {
                    // No digit detected - this is silence
                    this.silenceCount++;
                    
                    // After enough silence, unlock detection for next digit
                    if (this.silenceCount >= this.requiredSilence) {
                        this.digitLocked = false;
                        this.consecutiveDetections = 0;
                        this.lastDetectedDigit = null;
                    }
                }
            }
            
            // Prevent buffer from growing too large
            if (this.sampleBuffer.length > this.blockSize * 4) {
                this.sampleBuffer = this.sampleBuffer.slice(-this.blockSize * 2);
            }
            
            return detectedDigit;
        }

        // Start a new transmission detection session
        startTransmission() {
            this.reset();
            this.transmissionStartTime = Date.now();
            this.isCapturingStart = true;

            // Stop capturing start window after 2000ms (2 seconds)
            this.startWindowTimeout = setTimeout(() => {
                this.isCapturingStart = false;
            }, 2000);
        }

        // End transmission and return detected IDs
        endTransmission() {
            if (this.startWindowTimeout) {
                clearTimeout(this.startWindowTimeout);
                this.startWindowTimeout = null;
            }

            const result = {
                startId: this.startWindowDigits,
                endId: this.endWindowDigits,
                allDigits: this.detectedDigits
            };

            this.reset();
            return result;
        }

        reset() {
            this.detectedDigits = '';
            this.lastConfirmedDigit = null;
            this.startWindowDigits = '';
            this.endWindowDigits = '';
            this.isCapturingStart = true;
            this.sampleBuffer = new Float32Array(0);
            this.consecutiveDetections = 0;
            this.lastDetectedDigit = null;
            this.lastDigitTime = 0;
            this.silenceCount = 0;
            this.digitLocked = false;
            this.emergencyTriggeredThisSession = false; // Reset emergency flag for new session
            if (this.startWindowTimeout) {
                clearTimeout(this.startWindowTimeout);
                this.startWindowTimeout = null;
            }
        }
        
        // Check for emergency trigger IMMEDIATELY when digits are detected
        checkImmediateEmergency() {
            // Skip if already triggered this session, or no callback/trigger configured
            if (this.emergencyTriggeredThisSession || !this.onEmergencyDetected) return;
            if (!emergencyEnabled || !emergencyTriggerDtmf || emergencyTriggerDtmf.length === 0) return;
            
            // Check if current detected digits contain the trigger
            const allDigits = this.detectedDigits;
            const triggerIndex = allDigits.indexOf(emergencyTriggerDtmf);
            
            if (triggerIndex !== -1) {
                this.emergencyTriggeredThisSession = true; // Prevent duplicate alerts
                
                // Extract caller ID from digits around the trigger
                const beforeTrigger = allDigits.substring(0, triggerIndex);
                const afterTrigger = allDigits.substring(triggerIndex + emergencyTriggerDtmf.length);
                const excessDigits = beforeTrigger + afterTrigger;
                
                // Resolve caller ID through alias if possible
                let callerId = excessDigits.length > 0 ? excessDigits : null;
                if (callerId && typeof resolveCallerId === 'function') {
                    callerId = resolveCallerId(callerId);
                }
                
                console.log('🚨 IMMEDIATE EMERGENCY DETECTED! 🚨', {
                    trigger: emergencyTriggerDtmf,
                    allDigits: allDigits,
                    callerId: callerId,
                    resourceId: this.resourceId
                });
                
                // Call the emergency callback
                this.onEmergencyDetected(this.resourceId, callerId);
            }
        }

        getDetectedString() {
            return this.detectedDigits;
        }
    }

    // ============================================================================
    // AUDIO INITIALIZATION
    // ============================================================================

    async function initAudioContext() {
        if (!audioContext || audioContext.state === 'closed') {
            // Request 48kHz for Opus compatibility
            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: OPUS_SAMPLE_RATE });
            
            if (audioContext.sampleRate !== OPUS_SAMPLE_RATE) {
                console.warn(`Requested ${OPUS_SAMPLE_RATE}Hz but got ${audioContext.sampleRate}Hz - audio quality may be affected`);
            }

            masterGainNode = audioContext.createGain();
            masterGainNode.gain.setValueAtTime(volumeToGain(masterVolume), audioContext.currentTime);
            masterGainNode.connect(audioContext.destination);

            // Initialize TX audio pipeline
            await initTxAudioPipeline();

            // Initialize Opus codec
            await initOpusCodec();

            // Setup audio for existing resources
            resources.forEach(r => setupResourceAudio(r));

            // Initialize microphone
            await initMicrophone();
        }

        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
    }

    async function initOpusCodec() {
        // Use WebCodecs API directly (built into Chrome/Edge/Safari)
        if (typeof AudioEncoder !== 'undefined') {
            console.log('Initializing WebCodecs Opus codec...');
            try {
                await initWebCodecsOpus();
                console.log('WebCodecs Opus codec initialized');
                return;
            } catch (e) {
                console.error('WebCodecs init failed:', e);
            }
        }
        
        console.error('No Opus codec available - WebCodecs API not supported');
        console.error('Audio encoding/decoding requires Chrome 94+, Edge 94+, or Safari 16.4+');
    }

    async function initWebCodecsOpus() {
        // WebCodecs-based Opus encoder/decoder
        // Track timestamp for proper frame sequencing (in microseconds)
        let encoderTimestamp = 0;
        const FRAME_DURATION_US = (OPUS_FRAME_SIZE / OPUS_SAMPLE_RATE) * 1000000; // 20ms = 20000us
        
        opusEncoder = {
            _isWebCodecs: true,
            _encoder: null,
            _encodedChunks: [],
            
            async init() {
                const self = this;
                this._encoder = new AudioEncoder({
                    output: (chunk) => {
                        const data = new Uint8Array(chunk.byteLength);
                        chunk.copyTo(data);
                        self._encodedChunks.push(data);
                    },
                    error: (e) => console.error('WebCodecs encode error:', e)
                });
                
                await this._encoder.configure({
                    codec: 'opus',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfChannels: 1,
                    bitrate: OPUS_BITRATE
                });
            },
            
            encode(int16Array, frameSize) {
                if (!this._encoder) return null;
                
                // Convert Int16 to Float32
                const float32 = new Float32Array(int16Array.length);
                for (let i = 0; i < int16Array.length; i++) {
                    float32[i] = int16Array[i] / 32768;
                }
                
                // Use incrementing timestamp for proper sequencing
                const audioData = new AudioData({
                    format: 'f32',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfFrames: float32.length,
                    numberOfChannels: 1,
                    timestamp: encoderTimestamp,
                    data: float32
                });
                
                encoderTimestamp += FRAME_DURATION_US;
                
                this._encoder.encode(audioData);
                audioData.close();
                
                // Return first available chunk (may be from previous frame due to async)
                if (this._encodedChunks.length > 0) {
                    return this._encodedChunks.shift();
                }
                return null;
            },
            
            reset() {
                encoderTimestamp = 0;
                this._encodedChunks = [];
            }
        };
        
        // Decoder with proper timestamp tracking and frame queuing
        let decoderTimestamp = 0;
        
        opusDecoder = {
            _isWebCodecs: true,
            _decoder: null,
            _decodedFrames: [],
            _pendingDecode: false,
            
            async init() {
                const self = this;
                this._decoder = new AudioDecoder({
                    output: (audioData) => {
                        const float32 = new Float32Array(audioData.numberOfFrames);
                        audioData.copyTo(float32, { planeIndex: 0 });
                        
                        // Convert Float32 to Int16
                        const int16 = new Int16Array(float32.length);
                        for (let i = 0; i < float32.length; i++) {
                            int16[i] = Math.max(-32768, Math.min(32767, float32[i] * 32768));
                        }
                        self._decodedFrames.push(int16);
                        self._pendingDecode = false;
                        audioData.close(); // Release memory
                    },
                    error: (e) => {
                        console.error('WebCodecs decode error:', e);
                        self._pendingDecode = false;
                    }
                });
                
                await this._decoder.configure({
                    codec: 'opus',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfChannels: 1
                });
            },
            
            decode(opusData) {
                if (!this._decoder) return null;
                
                try {
                    const chunk = new EncodedAudioChunk({
                        type: 'key',
                        timestamp: decoderTimestamp,
                        data: opusData
                    });
                    
                    decoderTimestamp += FRAME_DURATION_US;
                    this._pendingDecode = true;
                    
                    this._decoder.decode(chunk);
                    
                    // Return all available frames concatenated
                    // This handles the async nature - we return whatever we have
                    if (this._decodedFrames.length > 0) {
                        // If multiple frames are ready, concatenate them
                        if (this._decodedFrames.length === 1) {
                            return this._decodedFrames.shift();
                        } else {
                            // Concatenate all available frames
                            const totalLength = this._decodedFrames.reduce((sum, f) => sum + f.length, 0);
                            const combined = new Int16Array(totalLength);
                            let offset = 0;
                            while (this._decodedFrames.length > 0) {
                                const frame = this._decodedFrames.shift();
                                combined.set(frame, offset);
                                offset += frame.length;
                            }
                            return combined;
                        }
                    }
                } catch (e) {
                    console.warn('Decode error, skipping frame:', e.message);
                }
                return null;
            },
            
            // Flush any remaining frames
            flush() {
                if (this._decodedFrames.length === 0) return null;
                
                const totalLength = this._decodedFrames.reduce((sum, f) => sum + f.length, 0);
                const combined = new Int16Array(totalLength);
                let offset = 0;
                while (this._decodedFrames.length > 0) {
                    const frame = this._decodedFrames.shift();
                    combined.set(frame, offset);
                    offset += frame.length;
                }
                return combined;
            },
            
            reset() {
                decoderTimestamp = 0;
                this._decodedFrames = [];
                this._pendingDecode = false;
            }
        };
        
        await opusEncoder.init();
        await opusDecoder.init();
    }

    // Create a per-resource Opus decoder to fix multi-resource audio garbling
    // Each resource needs its own decoder state to prevent interference
    async function initResourceOpusDecoder(resourceId) {
        // Create independent decoder for this resource
        const FRAME_DURATION_US = (OPUS_FRAME_SIZE / OPUS_SAMPLE_RATE) * 1000000;
        let decoderTimestamp = 0;
        
        const decoder = {
            _isWebCodecs: true,
            _decoder: null,
            _decodedFrames: [],
            _pendingDecode: false,
            resourceId: resourceId,
            
            async init() {
                const self = this;
                this._decoder = new AudioDecoder({
                    output: (audioData) => {
                        const float32 = new Float32Array(audioData.numberOfFrames);
                        audioData.copyTo(float32, { planeIndex: 0 });
                        
                        // Convert Float32 to Int16
                        const int16 = new Int16Array(float32.length);
                        for (let i = 0; i < float32.length; i++) {
                            int16[i] = Math.max(-32768, Math.min(32767, float32[i] * 32768));
                        }
                        self._decodedFrames.push(int16);
                        self._pendingDecode = false;
                        audioData.close();
                    },
                    error: (e) => {
                        console.error(`WebCodecs decode error (resource ${self.resourceId}):`, e);
                        self._pendingDecode = false;
                    }
                });
                
                await this._decoder.configure({
                    codec: 'opus',
                    sampleRate: OPUS_SAMPLE_RATE,
                    numberOfChannels: 1
                });
            },
            
            decode(opusData) {
                if (!this._decoder) return null;
                
                try {
                    const chunk = new EncodedAudioChunk({
                        type: 'key',
                        timestamp: decoderTimestamp,
                        data: opusData
                    });
                    
                    decoderTimestamp += FRAME_DURATION_US;
                    this._pendingDecode = true;
                    
                    this._decoder.decode(chunk);
                    
                    // Return available frames
                    if (this._decodedFrames.length > 0) {
                        if (this._decodedFrames.length === 1) {
                            return this._decodedFrames.shift();
                        } else {
                            const totalLength = this._decodedFrames.reduce((sum, f) => sum + f.length, 0);
                            const combined = new Int16Array(totalLength);
                            let offset = 0;
                            while (this._decodedFrames.length > 0) {
                                const frame = this._decodedFrames.shift();
                                combined.set(frame, offset);
                                offset += frame.length;
                            }
                            return combined;
                        }
                    }
                } catch (e) {
                    console.warn(`Decode error (resource ${this.resourceId}):`, e.message);
                }
                return null;
            },
            
            reset() {
                decoderTimestamp = 0;
                this._decodedFrames = [];
                this._pendingDecode = false;
            },
            
            close() {
                if (this._decoder) {
                    try {
                        this._decoder.close();
                    } catch (e) {}
                    this._decoder = null;
                }
            }
        };
        
        await decoder.init();
        resourceOpusDecoders.set(resourceId, decoder);
        console.log(`Created per-resource Opus decoder for resource ${resourceId}`);
    }

    function createOpusCodecs() {
        // This is called when external library is loaded
        // Implementation handled by initOpusCodec polling
    }

    async function initTxAudioPipeline() {
        // Create a merger node that combines mic + generated tones for TX
        txMergerNode = audioContext.createGain();
        txMergerNode.gain.setValueAtTime(1, audioContext.currentTime);

        // Create ScriptProcessor to capture merged TX audio
        // Buffer size of 4096 gives us ~85ms of audio at 48kHz
        txProcessorNode = audioContext.createScriptProcessor(4096, 1, 1);
        txProcessorNode.onaudioprocess = handleTxAudioProcess;

        // Connect merger to processor (processor output goes nowhere - we just capture)
        txMergerNode.connect(txProcessorNode);
        txProcessorNode.connect(audioContext.destination); // Required for ScriptProcessor to work

        console.log('TX audio pipeline initialized');
    }

    function handleTxAudioProcess(event) {
        // Only process if we are actively transmitting
        if (activeTxIds.length === 0 || !opusEncoder) return;

        const inputData = event.inputBuffer.getChannelData(0);
        
        // Update VU meter with TX level
        updateVuMeter('tx', inputData);
        
        // Add samples to buffer (with safety limit)
        const maxBufferSize = OPUS_FRAME_SIZE * 10; // Max 10 frames buffered
        for (let i = 0; i < inputData.length && pcmTxBuffer.length < maxBufferSize; i++) {
            pcmTxBuffer.push(inputData[i]);
        }

        // Process complete frames (960 samples = 20ms at 48kHz)
        let framesProcessed = 0;
        const maxFramesPerCallback = 5;
        
        while (pcmTxBuffer.length >= OPUS_FRAME_SIZE && framesProcessed < maxFramesPerCallback) {
            framesProcessed++;
            const frame = pcmTxBuffer.splice(0, OPUS_FRAME_SIZE);
            
            // Convert Float32 [-1, 1] to Int16 [-32768, 32767] (v1 style)
            const int16Frame = new Int16Array(OPUS_FRAME_SIZE);
            for (let i = 0; i < OPUS_FRAME_SIZE; i++) {
                int16Frame[i] = Math.max(-32768, Math.min(32767, frame[i] * 32768));
            }

            try {
                let opusPacket = null;
                
                // Handle different encoder APIs
                if (opusEncoder._isLibopus) {
                    // libopusjs API: input() then output()
                    opusEncoder.input(int16Frame);
                    opusPacket = opusEncoder.output();
                } else if (opusEncoder._isWebCodecs) {
                    // WebCodecs API
                    opusPacket = opusEncoder.encode(int16Frame, OPUS_FRAME_SIZE);
                } else {
                    // OpusScript API: encode(int16Array, frameSize)
                    opusPacket = opusEncoder.encode(int16Frame, OPUS_FRAME_SIZE);
                }
                
                // Debug logging for first few packets
                txPacketCount = (txPacketCount || 0) + 1;
                if (txPacketCount <= 5) {
                    console.log(`TX packet #${txPacketCount}: input ${int16Frame.length} samples, output ${opusPacket ? opusPacket.length : 'null'} bytes`);
                    if (opusPacket && opusPacket.length > 0) {
                        console.log(`  First bytes: ${Array.from(opusPacket.slice(0, 8)).map(b => b.toString(16).padStart(2,'0')).join(' ')}`);
                    }
                }
                
                if (opusPacket && opusPacket.length > 0) {
                    // Log periodically (every 50 packets = ~1 second at 20ms frames)
                    if (txPacketCount % 50 === 0) {
                        console.log(`TX audio: packet #${txPacketCount}, ${opusPacket.length} bytes`);
                    }
                    
                    // Send to all active TX resources
                    // opusPacket is Uint8Array, use .buffer to get ArrayBuffer
                    for (const resourceId of activeTxIds) {
                        sendSerialPacket(COMMAND_HOST_TX_AUDIO, opusPacket.buffer, resourceId);
                    }
                }
            } catch (e) {
                console.error('Opus encode error:', e);
            }
        }
    }

    async function initMicrophone() {
        try {
            micStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                    sampleRate: OPUS_SAMPLE_RATE
                }
            });

            micSource = audioContext.createMediaStreamSource(micStream);
            micGainNode = audioContext.createGain();
            micGainNode.gain.setValueAtTime(volumeToGain(micVolume), audioContext.currentTime);
            micSource.connect(micGainNode);
            
            // Connect mic to TX merger (for transmission)
            micGainNode.connect(txMergerNode);

            console.log("Microphone initialized and connected to TX pipeline");
        } catch (e) {
            console.error("Failed to initialize microphone:", e);
        }
    }

    // Mic muting for tone-only transmissions (pages, priority tones, alert tones)
    let micMutedForTones = false;
    let savedMicGain = 1.0;
    
    function muteMicForTones() {
        if (!micGainNode || micMutedForTones) return;
        savedMicGain = micGainNode.gain.value;
        micGainNode.gain.setValueAtTime(0, audioContext.currentTime);
        micMutedForTones = true;
        console.log('Microphone muted for tone transmission');
    }
    
    function unmuteMicForTones() {
        if (!micGainNode || !micMutedForTones) return;
        micGainNode.gain.setValueAtTime(savedMicGain, audioContext.currentTime);
        micMutedForTones = false;
        console.log('Microphone unmuted after tone transmission');
    }

    // VU Meter Functions
    // VU meter throttling - smoother updates at display refresh rate
    // (vuMeterAnimationFrame declared in global state section above)
    let pendingVuLevel = 0;
    let pendingVuMode = 'idle';
    
    function updateVuMeter(mode, audioData) {
        // Calculate RMS level from audio data
        let sum = 0;
        for (let i = 0; i < audioData.length; i++) {
            sum += audioData[i] * audioData[i];
        }
        const rms = Math.sqrt(sum / audioData.length);
        
        // Convert to percentage (0-100), with some amplification for visibility
        const level = Math.min(100, rms * 300);
        
        // Store pending values and schedule update via requestAnimationFrame
        pendingVuLevel = Math.max(pendingVuLevel, level); // Keep peak level
        pendingVuMode = mode;
        
        if (!vuMeterAnimationFrame) {
            vuMeterAnimationFrame = requestAnimationFrame(applyVuMeterUpdate);
        }
    }
    
    function applyVuMeterUpdate() {
        vuMeterAnimationFrame = null;
        
        const vuIcon = document.getElementById('vuMeterIcon');
        const vuBar = document.getElementById('vuMeterBar');
        
        if (!vuIcon || !vuBar) return;
        
        // Update icon based on mode
        if (pendingVuMode === 'tx') {
            vuIcon.className = 'fas fa-microphone text-red-500 w-4 text-center';
            vuIcon.style.visibility = 'visible';
            vuMeterMode = 'tx';
        } else if (pendingVuMode === 'rx') {
            vuIcon.className = 'fas fa-volume-off text-green-500 w-4 text-center';
            vuIcon.style.visibility = 'visible';
            vuMeterMode = 'rx';
        }
        
        // Update bar level and color
        vuBar.style.width = pendingVuLevel + '%';
        if (pendingVuLevel > 80) {
            vuBar.className = 'h-full bg-red-500 transition-all duration-75';
        } else if (pendingVuLevel > 50) {
            vuBar.className = 'h-full bg-yellow-500 transition-all duration-75';
        } else {
            vuBar.className = 'h-full bg-green-500 transition-all duration-75';
        }
        
        // Reset pending level for next batch
        pendingVuLevel = 0;
    }
    
    function resetVuMeter() {
        const vuIcon = document.getElementById('vuMeterIcon');
        const vuBar = document.getElementById('vuMeterBar');
        
        if (vuIcon) {
            vuIcon.style.visibility = 'hidden';
        }
        if (vuBar) {
            vuBar.style.width = '0%';
        }
        vuMeterMode = 'idle';
        pendingVuLevel = 0;
        pendingVuMode = 'idle';
    }

    function setupResourceAudio(resource) {
        if (!audioContext || resourceAudioNodes.has(resource.id)) return;

        // Create audio nodes for this resource
        const gainNode = audioContext.createGain();
        const pannerNode = audioContext.createStereoPanner();
        const analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;

        // For recording - separate gain node that stays at full volume
        const recordingGainNode = audioContext.createGain();
        recordingGainNode.gain.setValueAtTime(1.0, audioContext.currentTime); // Always full volume
        const recordingDestination = audioContext.createMediaStreamDestination();

        // Initial settings for playback gain
        gainNode.gain.setValueAtTime(0, audioContext.currentTime); // Start silent
        const targetPan = resource.selected ? -1 : 1; // Left for selected, right for unselected
        pannerNode.pan.setValueAtTime(targetPan, audioContext.currentTime);

        // Connect: 
        // For playback: gainNode -> pannerNode -> masterGainNode -> destination
        // For analysis: gainNode -> analyserNode (for DTMF detection)
        // For recording: recordingGainNode -> recordingDestination (always at full volume)
        gainNode.connect(pannerNode);
        gainNode.connect(analyserNode);
        recordingGainNode.connect(recordingDestination);
        pannerNode.connect(masterGainNode);

        // Create DTMF decoder for this resource
        const dtmfDecoder = new DTMFDecoder(audioContext.sampleRate);
        dtmfDecoder.resourceId = resource.id;
        dtmfDecoder.onEmergencyDetected = (resourceId, callerId) => {
            // This triggers immediately when emergency DTMF is detected
            triggerEmergency(resourceId, callerId || emergencyTriggerDtmf);
            // Also update the caller ID display immediately
            const nodes = resourceAudioNodes.get(resourceId);
            if (nodes && callerId) {
                nodes.lastCallerId = callerId;
                nodes.lastCallerIdTime = Date.now();
                renderResources(); // Update the display
            }
        };
        dtmfDecoder.onDigitDetected = (resourceId, allDigits) => {
            // Real-time caller ID update as digits are detected
            if (!allDigits) return;
            
            const nodes = resourceAudioNodes.get(resourceId);
            if (!nodes) return;
            
            // Strip out emergency trigger if present to get actual caller ID
            let callerDigits = allDigits;
            if (emergencyEnabled && emergencyTriggerDtmf && emergencyTriggerDtmf.length > 0) {
                const triggerIndex = allDigits.indexOf(emergencyTriggerDtmf);
                if (triggerIndex !== -1) {
                    // Remove the emergency trigger, keep remaining digits as caller ID
                    const beforeTrigger = allDigits.substring(0, triggerIndex);
                    const afterTrigger = allDigits.substring(triggerIndex + emergencyTriggerDtmf.length);
                    callerDigits = beforeTrigger + afterTrigger;
                }
            }
            
            // Resolve through alias system if enabled
            let displayId = callerDigits || allDigits; // Fall back to allDigits if no caller digits
            if (aliasDecodingEnabled && displayId) {
                const resolved = resolveCallerId(displayId);
                // Only update if we got a resolved name OR if we don't have one yet
                if (resolved !== displayId || !nodes.currentCallerId) {
                    displayId = resolved;
                }
            }
            
            // Only update if we have something to display
            if (displayId) {
                // If we already have a resolved alias, keep it unless new digits change things
                const currentIsAlias = nodes.currentCallerId && !/^\d+$/.test(nodes.currentCallerId);
                const newIsAlias = !/^\d+$/.test(displayId);
                
                // Prefer keeping an alias over raw digits
                if (currentIsAlias && !newIsAlias && callerDigits === allDigits) {
                    // Current is alias, new is digits, and no emergency trigger stripped
                    // This means we're just adding more digits - keep the alias if it still matches
                    return;
                }
                
                nodes.currentCallerId = displayId;
                nodes.lastCallerId = displayId;
                nodes.lastCallerIdTime = Date.now();
            }
            
            // Throttle re-renders to avoid performance issues (max every 100ms)
            if (!dtmfDecoder._lastRenderTime || Date.now() - dtmfDecoder._lastRenderTime > 100) {
                dtmfDecoder._lastRenderTime = Date.now();
                renderResources();
            }
        };
        resourceDtmfDecoders.set(resource.id, dtmfDecoder);

        resourceAudioNodes.set(resource.id, {
            gainNode,
            pannerNode,
            analyserNode,
            recordingGainNode,
            recordingDestination,
            lastRssi: 0,
            currentCallerId: null,
            lastCallerId: null, // Persisted caller ID for display
            lastCallerIdTime: 0, // Timestamp when caller ID was last updated
            previousVolume: resource.volume,
            nextPlayTime: 0, // For scheduled audio playback to eliminate clicks
            lastSample: 0, // Track last sample for crossfade blending
            jitterBuffer: [], // Buffer for smooth playback
            playbackStarted: false // Flag to track if playback has begun
        });
    }

    function removeResourceAudio(resourceId) {
        const nodes = resourceAudioNodes.get(resourceId);
        if (nodes) {
            try {
                nodes.gainNode.disconnect();
                nodes.pannerNode.disconnect();
                nodes.analyserNode.disconnect();
            } catch (e) {}
            resourceAudioNodes.delete(resourceId);
        }
        resourceDtmfDecoders.delete(resourceId);
    }

    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================

    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function showModal(modalId) {
        const modal = document.getElementById(modalId);
        modal.classList.remove('hidden');
        modal.classList.add('flex');
    }

    function hideModal(modalId) {
        const modal = document.getElementById(modalId);
        modal.classList.add('hidden');
        modal.classList.remove('flex');
    }

    function isAnyModalOpen() {
        return modalIds.some(id => {
            const modal = document.getElementById(id);
            return modal && modal.classList.contains('flex');
        });
    }

    // Help Topic Accordion
    let currentHelpTopic = null;

    function toggleHelpTopic(topicId) {
        const content = document.getElementById(topicId);
        const icon = document.getElementById(topicId + '-icon');
        
        if (!content || !icon) return;
        
        // If clicking the currently open topic, close it
        if (currentHelpTopic === topicId) {
            content.classList.add('hidden');
            icon.classList.remove('fa-caret-down');
            icon.classList.add('fa-caret-right');
            currentHelpTopic = null;
            return;
        }
        
        // Close currently open topic if any
        if (currentHelpTopic) {
            const prevContent = document.getElementById(currentHelpTopic);
            const prevIcon = document.getElementById(currentHelpTopic + '-icon');
            if (prevContent) prevContent.classList.add('hidden');
            if (prevIcon) {
                prevIcon.classList.remove('fa-caret-down');
                prevIcon.classList.add('fa-caret-right');
            }
        }
        
        // Open the clicked topic
        content.classList.remove('hidden');
        icon.classList.remove('fa-caret-right');
        icon.classList.add('fa-caret-down');
        currentHelpTopic = topicId;
    }

    function showConfirmDialog(title, message, onConfirm) {
        document.getElementById('confirmTitle').textContent = title;
        document.getElementById('confirmMessage').textContent = message;

        const confirmOk = document.getElementById('confirmOk');
        const confirmCancel = document.getElementById('confirmCancel');

        const handleConfirm = () => {
            hideModal('confirmModal');
            onConfirm();
            cleanup();
        };

        const handleCancel = () => {
            hideModal('confirmModal');
            cleanup();
        };

        const cleanup = () => {
            confirmOk.removeEventListener('click', handleConfirm);
            confirmCancel.removeEventListener('click', handleCancel);
        };

        confirmOk.addEventListener('click', handleConfirm);
        confirmCancel.addEventListener('click', handleCancel);
        showModal('confirmModal');
    }

    function showError(title, message) {
        document.getElementById('errorTitle').textContent = title;
        document.getElementById('errorMessage').textContent = message;
        showModal('errorModal');
    }

    function showSuccess(title, message) {
        document.getElementById('successTitle').textContent = title;
        document.getElementById('successMessage').textContent = message;
        showModal('successModal');
    }

    // Check if frequency matches module type, returns error message or null if OK
    function checkFrequencyMismatch(resource, moduleType) {
        const freq = resource.frequency;
        const isVhfFreq = freq >= 134 && freq <= 174;
        const isUhfFreq = freq >= 400 && freq <= 480;
        const isVhfModule = moduleType === RF_MODULE_VHF;
        const isUhfModule = moduleType === RF_MODULE_UHF;
        
        if (isVhfFreq && isUhfModule) {
            return `VHF frequency (${freq} MHz) configured, but this KV4P-HT has a UHF radio module. Please set a UHF frequency (400-480 MHz).`;
        } else if (isUhfFreq && isVhfModule) {
            return `UHF frequency (${freq} MHz) configured, but this KV4P-HT has a VHF radio module. Please set a VHF frequency (134-174 MHz).`;
        } else if (!isVhfFreq && !isUhfFreq) {
            return `Frequency ${freq} MHz is outside valid bands. Please set a VHF (134-174 MHz) or UHF (400-480 MHz) frequency.`;
        }
        return null; // No mismatch
    }

    function validateDTMFString(str) {
        return /^[0-9A-Da-d*#,]*$/.test(str);
    }

    // Volume conversion helper - converts 0-7 scale to 0-1 for Web Audio API
    function volumeToGain(vol) {
        // vol is 0-7, output is 0-1
        // Using exponential curve for more natural volume response
        if (vol <= 0) return 0;
        return Math.pow(vol / 7, 2);  // Exponential curve: 0=0, 3.5≈0.25, 7=1
    }

    function sanitizeDTMFString(str) {
        return str.toUpperCase().replace(/[^0-9A-D*#,]/g, '');
    }

    // ============================================================================
    // TONE GENERATION (Updated to route through TX pipeline)
    // ============================================================================

    function generateTone(frequency, duration, volume = 0.25, waveform = 'sine', forTx = false) {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        
        // Always connect to speakers
        gainNode.connect(masterGainNode);
        
        // If transmitting, also connect to TX pipeline
        if (forTx && txMergerNode && activeTxIds.length > 0) {
            gainNode.connect(txMergerNode);
            // Track for paging cancellation
            if (isTransmittingPages) {
                activePagingOscillators.push({ oscillator, gainNode });
            }
        }

        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = waveform;

        // Envelope to prevent clicks
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.005);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + duration - 0.005);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
        
        // Clean up from tracking array when done
        oscillator.onended = () => {
            activePagingOscillators = activePagingOscillators.filter(o => o.oscillator !== oscillator);
        };
    }

    // Bonk/Talk Denied Tone: 300Hz for 1000ms (local only, not transmitted)
    function playBonkSound() {
        generateTone(300, 1.0, 0.25, 'sine', false);
    }

    // Talk Permit Tone: 900Hz, 25ms tone, 25ms gap, repeated 3 times (local only)
    function playTalkPermitTone() {
        const toneLength = 0.025; // 25ms
        const gapLength = 0.025;  // 25ms
        
        for (let i = 0; i < 3; i++) {
            const startTime = i * (toneLength + gapLength);
            setTimeout(() => generateTone(900, toneLength, 0.2, 'sine', false), startTime * 1000);
        }
    }

    // Priority Tone: 675Hz for 750ms (TRANSMITTED when active)
    async function playPriorityTone(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.isConnected) {
            // Just play locally if not connected
            generateTone(675, 0.75, 0.25, 'sine', false);
            return;
        }
        
        // IMPORTANT: Don't transmit priority tone if ANY other transmission is active
        // This prevents cross-talk between resources using the shared TX audio pipeline
        if (activeTxIds.length > 0 || isTransmittingPages) {
            console.log(`Priority tone for resource ${resourceId} skipped - other TX active`);
            // Queue it for when TX ends - the priorityToneQueued flag handles this
            resource.priorityToneQueued = true;
            return;
        }
        
        // Check if already transmitting on this resource
        if (resource.busy && resource.recordingType === 'tx') {
            // Already transmitting voice, don't play priority tone
            console.log(`Priority tone for resource ${resourceId} skipped - resource busy with voice TX`);
            return;
        }
        
        // Need to key up the radio for this resource specifically
        try {
            // Mark as busy for priority tone
            resource.busy = true;
            resource.recordingType = 'priority';
            
            // Mute microphone during tone
            muteMicForTones();
            
            // Send GROUP command to ensure correct frequency
            await sendGroupCommand(resource);
            
            // Key the radio
            await sendSerialPacket(COMMAND_HOST_PTT_DOWN, null, resourceId);
            
            // Wait for radio to key up (150ms for talk permit)
            await delay(150);
            
            // Add this resource to active TX for the tone routing
            activeTxIds.push(resourceId);
            
            // Set priority tone playing flag for stack light
            priorityTonePlaying = true;
            updateStackLight();
            
            // Play the tone (will route through TX pipeline)
            generateTone(675, 0.75, 0.25, 'sine', true);
            
            // Wait for tone to complete plus small buffer
            await delay(800);
            
            // Clear priority tone flag
            priorityTonePlaying = false;
            updateStackLight();
            
            // Unkey the radio
            await sendSerialPacket(COMMAND_HOST_PTT_UP, null, resourceId);
            
            // Unmute microphone
            unmuteMicForTones();
            
            // Remove from active TX
            activeTxIds = activeTxIds.filter(id => id !== resourceId);
            
            // Clear busy state
            resource.busy = false;
            resource.recordingType = null;
            
            // Reset VU meter since we're done transmitting
            resetVuMeter();
            
            renderResources();
            
            // Update stack light after full cleanup
            updateStackLight();
        } catch (e) {
            console.error('Failed to transmit priority tone:', e);
            // Cleanup on error
            priorityTonePlaying = false;
            unmuteMicForTones();
            activeTxIds = activeTxIds.filter(id => id !== resourceId);
            resource.busy = false;
            resource.recordingType = null;
            resetVuMeter();
            renderResources();
            updateStackLight();
        }
    }

    // ============================================================================
    // DTMF TONE GENERATION (Updated to route through TX pipeline)
    // ============================================================================

    function generateDTMFTone(char, duration = 0.1, volume = 0.2, forTx = false) {
        if (!audioContext || !DTMF_FREQS[char.toUpperCase()]) return;

        const [lowFreq, highFreq] = DTMF_FREQS[char.toUpperCase()];

        const osc1 = audioContext.createOscillator();
        const osc2 = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        osc1.connect(gainNode);
        osc2.connect(gainNode);
        
        // Always connect to speakers
        gainNode.connect(masterGainNode);
        
        // If transmitting, also connect to TX pipeline
        if (forTx && txMergerNode && activeTxIds.length > 0) {
            gainNode.connect(txMergerNode);
            // Track for paging cancellation
            if (isTransmittingPages) {
                activePagingOscillators.push({ oscillator: osc1, gainNode });
                activePagingOscillators.push({ oscillator: osc2, gainNode });
            }
        }

        osc1.frequency.setValueAtTime(lowFreq, audioContext.currentTime);
        osc2.frequency.setValueAtTime(highFreq, audioContext.currentTime);

        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.005);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + duration - 0.005);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

        osc1.start(audioContext.currentTime);
        osc2.start(audioContext.currentTime);
        osc1.stop(audioContext.currentTime + duration);
        osc2.stop(audioContext.currentTime + duration);
        
        // Clean up from tracking array when done
        osc1.onended = () => {
            activePagingOscillators = activePagingOscillators.filter(o => o.oscillator !== osc1);
        };
        osc2.onended = () => {
            activePagingOscillators = activePagingOscillators.filter(o => o.oscillator !== osc2);
        };
    }

    async function transmitDTMFString(dtmfString) {
        const toneDuration = 0.1;  // 100ms
        const gapDuration = 0.05;  // 50ms gap

        for (let i = 0; i < dtmfString.length; i++) {
            if (pagingCancelled || (!isTransmittingPages && activeTxIds.length === 0)) break;

            const char = dtmfString[i].toUpperCase();
            if (char === ',') {
                // Comma = 2 second pause (check for cancel every 100ms)
                for (let j = 0; j < 20; j++) {
                    if (pagingCancelled) break;
                    await delay(100);
                }
            } else if (DTMF_FREQS[char]) {
                generateDTMFTone(char, toneDuration, 0.2, true); // forTx = true
                await delay((toneDuration + gapDuration) * 1000);
            }
        }
    }

    // ============================================================================
    // 2-TONE GENERATION (Updated to route through TX pipeline)
    // ============================================================================

    async function transmit2Tone(freq1, freq2) {
        if (!audioContext) return;

        // First tone - 1 second (forTx = true)
        generateTone(freq1, 1.0, 0.25, 'sine', true);
        // Wait with cancel check (every 100ms)
        for (let i = 0; i < 10; i++) {
            if (pagingCancelled) return;
            await delay(100);
        }

        if (pagingCancelled || (!isTransmittingPages && activeTxIds.length === 0)) return;

        // Second tone - 3 seconds (forTx = true)
        generateTone(freq2, 3.0, 0.25, 'sine', true);
        // Wait with cancel check (every 100ms)
        for (let i = 0; i < 30; i++) {
            if (pagingCancelled) return;
            await delay(100);
        }
    }

    // ============================================================================
    // EMERGENCY WHOOP TONE
    // ============================================================================
    // EMERGENCY ALERT TONE - Dual Frequency Pulse
    // Primary: 853 Hz, Secondary: 960 Hz (43% amplitude)
    // Pattern: pulse (107ms) → gap (47ms) → pulse (107ms) → long gap (247ms) → repeat
    // ============================================================================

    function startEmergencyWhoop() {
        if (emergencyToneScheduler) return; // Already playing

        if (!audioContext) return;

        // Tone parameters
        const frequency1 = 853;
        const frequency2 = 960;
        const mixLevel = 0.43;
        const volume = 0.35;
        const pulseDuration = 107; // ms
        const shortGap = 47; // ms
        const longGap = 247; // ms
        const attackTime = 0.005;
        const releaseTime = 0.005;

        // Calculate cycle time in seconds
        const cycleTime = (pulseDuration * 2 + shortGap + longGap) / 1000; // ~0.448 seconds

        emergencyToneStartTime = audioContext.currentTime;

        // Function to create a single dual-tone pulse
        function createPulse(startTime) {
            const durationSec = pulseDuration / 1000;

            // Create two oscillators for dual-tone
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gain1 = audioContext.createGain();
            const gain2 = audioContext.createGain();

            osc1.type = 'sine';
            osc1.frequency.value = frequency1;
            osc2.type = 'sine';
            osc2.frequency.value = frequency2;

            osc1.connect(gain1);
            osc2.connect(gain2);
            gain1.connect(masterGainNode);
            gain2.connect(masterGainNode);

            // Primary envelope
            gain1.gain.setValueAtTime(0, startTime);
            gain1.gain.linearRampToValueAtTime(volume, startTime + attackTime);
            gain1.gain.setValueAtTime(volume, startTime + durationSec - releaseTime);
            gain1.gain.linearRampToValueAtTime(0, startTime + durationSec);

            // Secondary envelope (scaled by mixLevel)
            const secondaryVol = volume * mixLevel;
            gain2.gain.setValueAtTime(0, startTime);
            gain2.gain.linearRampToValueAtTime(secondaryVol, startTime + attackTime);
            gain2.gain.setValueAtTime(secondaryVol, startTime + durationSec - releaseTime);
            gain2.gain.linearRampToValueAtTime(0, startTime + durationSec);

            osc1.start(startTime);
            osc1.stop(startTime + durationSec + 0.01);
            osc2.start(startTime);
            osc2.stop(startTime + durationSec + 0.01);

            emergencyToneNodes.push(
                { osc: osc1, gain: gain1 },
                { osc: osc2, gain: gain2 }
            );

            return durationSec;
        }

        // Schedule one complete cycle (double-pulse pattern)
        function scheduleCycle() {
            if (!emergencyToneScheduler) return;

            // Clean up old nodes that have finished
            const now = audioContext.currentTime;
            emergencyToneNodes = emergencyToneNodes.filter(node => {
                try {
                    // Keep nodes that might still be playing
                    return true;
                } catch (e) {
                    return false;
                }
            });

            // Schedule ahead by 2 cycles to ensure smooth playback
            let scheduleTime = emergencyToneStartTime;
            const scheduleAhead = now + 1.0; // Schedule 1 second ahead

            while (scheduleTime < scheduleAhead) {
                // First pulse
                createPulse(scheduleTime);
                scheduleTime += pulseDuration / 1000;
                scheduleTime += shortGap / 1000;

                // Second pulse
                createPulse(scheduleTime);
                scheduleTime += pulseDuration / 1000;
                scheduleTime += longGap / 1000;
            }

            emergencyToneStartTime = scheduleTime;
        }

        // Initial scheduling
        scheduleCycle();

        // Continue scheduling every 400ms
        emergencyToneScheduler = setInterval(scheduleCycle, 400);
    }

    function stopEmergencyWhoop() {
        if (emergencyToneScheduler) {
            clearInterval(emergencyToneScheduler);
            emergencyToneScheduler = null;
        }

        const now = audioContext ? audioContext.currentTime : 0;

        emergencyToneNodes.forEach(({ osc, gain }) => {
            try {
                gain.gain.cancelScheduledValues(now);
                gain.gain.setValueAtTime(0, now);
                osc.stop(now + 0.01);
            } catch (e) {}
        });

        emergencyToneNodes = [];
        emergencyToneStartTime = 0;
    }

    // ============================================================================
    // THEME MANAGEMENT
    // ============================================================================

    function applyTheme() {
        let isDark = false;

        if (currentTheme === 'dark') {
            isDark = true;
        } else if (currentTheme === 'light') {
            isDark = false;
        } else {
            // System default
            isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        }

        document.documentElement.classList.toggle('dark', isDark);
    }

    function initTheme() {
        applyTheme();

        // Listen for theme select changes - apply immediately
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            themeSelect.addEventListener('change', function() {
                currentTheme = this.value;
                applyTheme();
                saveToLocalStorage(); // Persist the change
            });
        }

        // Listen for system theme changes
        if (window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                if (currentTheme === 'system') {
                    applyTheme();
                }
            });
        }
    }

    // ============================================================================
    // RESOURCE RENDERING
    // ============================================================================

    function renderResources() {
        const grid = document.getElementById('resourcesGrid');
        grid.innerHTML = '';

        resources.forEach(resource => {
            grid.appendChild(createResourceCard(resource));
        });
    }

    function createResourceCard(resource) {
        const card = document.createElement('div');
        card.setAttribute('data-resource-id', resource.id); // For targeted DOM updates
        const isEmergency = activeEmergencyResourceIds.has(resource.id);
        const isExpanded = expandedResources.has(resource.id);
        const nodes = resourceAudioNodes.get(resource.id);
        const currentCallerId = nodes ? nodes.currentCallerId : null;
        const lastCallerId = nodes ? nodes.lastCallerId : null;
        const lastCallerIdTime = nodes ? nodes.lastCallerIdTime : 0;
        const rssiLevel = nodes ? nodes.lastRssi : 0;
        const isTransmitting = activeTxIds.includes(resource.id);
        const isReceiving = resource.busy && resource.recordingType === 'rx';
        
        // Calculate caller ID opacity (fades over 10 seconds)
        const callerIdAge = Date.now() - lastCallerIdTime;
        const callerIdFadeMs = 10000; // 10 seconds
        const callerIdOpacity = lastCallerId && lastCallerIdTime > 0 
            ? Math.max(0, 1 - (callerIdAge / callerIdFadeMs))
            : 0;
        const showCallerId = callerIdOpacity > 0 || isReceiving;
        const displayCallerId = isReceiving ? currentCallerId : lastCallerId;

        // Card classes - emergency and selected can both be active
        let cardClasses = 'bg-white dark:bg-gray-800 rounded-lg shadow-sm border-2 transition-all duration-200 relative overflow-hidden';
        if (isEmergency) {
            cardClasses += ' emergency-active border-red-500';
            // Also add selected shading if selected (emergency overrides border but not background)
            if (resource.selected) {
                cardClasses += ' resource-selected';
            }
        } else if (resource.selected) {
            cardClasses += ' resource-selected border-primary';
        } else {
            cardClasses += ' border-gray-200 dark:border-gray-700';
        }
        card.className = cardClasses;

        // Tone type display
        let toneDisplay = 'CSQ';
        if (resource.toneType === 'ctcss' && resource.ctcssTone) {
            toneDisplay = `CTCSS ${resource.ctcssTone} Hz`;
        }

        // Activity log HTML
        const activityLogHtml = createActivityLogHtml(resource, isExpanded);

        // Instant TX button styling - turns yellow when transmitting
        const txBtnClasses = isTransmitting 
            ? 'bg-yellow-500 text-white animate-pulse' 
            : 'bg-red-500 hover:bg-red-600 text-white';

        // Status indicators row - connection, module type, speaker, RSSI, caller ID
        // All fixed-width for stable layout
        const rfTypeStr = resource.rfModuleType === RF_MODULE_UHF ? 'UHF' : 
                          resource.rfModuleType === RF_MODULE_VHF ? 'VHF' : '';
        const statusRowHtml = `
            <div class="flex items-center gap-2 mt-1 text-xs">
                <!-- Connection Status - fixed width -->
                <span class="inline-flex items-center px-1.5 py-0.5 rounded text-xs font-medium w-24 justify-center
                    ${resource.isConnected ? 
                        (resource.handshakeComplete ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' :
                         'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200') : 
                        'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'}">
                    <i class="fas ${resource.isConnected ? (resource.handshakeComplete ? 'fa-link' : 'fa-spinner fa-spin') : 'fa-unlink'} mr-1"></i>
                    ${resource.isConnected ? (resource.handshakeComplete ? (rfTypeStr || 'Ready') : 'Init...') : 'Disconnected'}
                </span>
                <!-- RX/TX Indicator - fixed width -->
                <span class="rx-tx-indicator w-5 text-center">
                    ${isReceiving ? '<i class="fas fa-volume-up text-blue-500 animate-pulse"></i>' : 
                      isTransmitting ? '<i class="fas fa-microphone text-red-500 animate-pulse"></i>' : 
                      '<i class="fas fa-volume-off text-gray-300 dark:text-gray-600"></i>'}
                </span>
                <!-- RSSI Meter - fixed width -->
                ${showRssi ? `<div class="rssi-meter flex gap-0.5 w-8">${createRssiMeterHtml(isReceiving ? rssiLevel : 0)}</div>` : ''}
                <!-- Caller ID - flexible width with fade -->
                <span class="caller-id-display flex-1 truncate font-mono text-blue-600 dark:text-blue-400 transition-opacity duration-500"
                      style="opacity: ${isReceiving ? 1 : callerIdOpacity.toFixed(2)};"
                      title="${displayCallerId || ''}">
                    ${showCallerId && displayCallerId ? displayCallerId : ''}
                </span>
            </div>
        `;

        card.innerHTML = `
            <div class="p-3">
                <!-- Main Content Row -->
                <div class="flex items-start gap-3">
                    <!-- Left Column: Instant Transmit Button -->
                    <div class="flex flex-col items-center flex-shrink-0">
                        <!-- Instant Transmit Button -->
                        <button onmousedown="startInstantTransmit(${resource.id}); event.stopPropagation();" 
                                onmouseup="stopTransmit(); event.stopPropagation();"
                                onmouseleave="stopTransmit()"
                                ontouchstart="startInstantTransmit(${resource.id}); event.stopPropagation(); event.preventDefault();"
                                ontouchend="stopTransmit(); event.stopPropagation(); event.preventDefault();"
                                class="instant-tx-btn rounded-lg font-medium transition-colors
                                ${txBtnClasses}
                                ${!resource.isConnected ? 'opacity-50 cursor-not-allowed' : ''}"
                                ${!resource.isConnected ? 'disabled' : ''}
                                title="Instant Transmit (PTT)">
                            <i class="fas fa-bolt"></i>
                        </button>
                    </div>

                    <!-- Resource Info (Center) -->
                    <div class="flex-1 min-w-0 resource-selectable rounded p-1 -m-1" onclick="toggleResourceSelection(${resource.id})">
                        <div class="flex justify-between items-start">
                            <div class="flex-1 min-w-0">
                                <h3 class="font-semibold text-base truncate">${escapeHtml(resource.name)}</h3>
                                <div class="text-sm text-gray-600 dark:text-gray-400 font-mono">
                                    ${resource.frequency.toFixed(5)} MHz
                                    ${resource.mode === 'half-duplex' && resource.transmitFrequency ? 
                                        `<span class="text-xs">→ ${resource.transmitFrequency.toFixed(5)}</span>` : ''}
                                </div>
                                <div class="text-xs text-gray-500">${toneDisplay}</div>
                                <!-- Status Row: Connection, Speaker, RSSI, Caller ID -->
                                ${statusRowHtml}
                            </div>
                        </div>
                    </div>

                    <!-- Right Side Buttons (Single Vertical Stack) -->
                    <div class="stacked-controls-vertical flex flex-col gap-1 flex-shrink-0">
                        <!-- Priority/Channel Marker (Top) -->
                        <button onclick="toggleResourcePriority(${resource.id}); event.stopPropagation();" 
                                class="rounded-lg text-sm font-medium transition-colors w-9 h-9 flex items-center justify-center
                                ${resource.priority ? 'bg-purple-500 text-white' : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'}"
                                title="Priority Tone (675Hz every 10s)">
                            <span class="priority-icon-wrapper">
                                <i class="fas fa-tower-cell"></i>
                                <i class="fas fa-music music-note-super ${resource.priority ? 'active' : ''}"></i>
                            </span>
                        </button>
                        <!-- Patch (Middle) -->
                        <button onclick="toggleResourcePatch(${resource.id}); event.stopPropagation();" 
                                class="rounded-lg text-sm font-medium transition-colors w-9 h-9 flex items-center justify-center
                                ${resource.patch ? 'bg-yellow-500 text-white' : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600'}"
                                title="Patch (cross-connect resources)">
                            <i class="fas fa-link"></i>
                        </button>
                        <!-- Edit Resource (Bottom) -->
                        <button onclick="editResource(${resource.id}); event.stopPropagation();" 
                                class="rounded-lg text-sm transition-colors w-9 h-9 flex items-center justify-center bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300"
                                title="Edit Resource">
                            <i class="fas fa-edit"></i>
                        </button>
                    </div>
                </div>

                <!-- Volume Slider -->
                <div class="flex items-center space-x-2 mt-3" onclick="event.stopPropagation();">
                    <i class="fas fa-volume-down text-gray-500 text-sm"></i>
                    <input type="range" min="0" max="7" value="${resource.volume}" step="1"
                           onchange="updateResourceVolume(${resource.id}, this.value)"
                           oninput="this.nextElementSibling.textContent = this.value"
                           class="flex-1 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span class="text-xs text-gray-500 w-6 text-right">${resource.volume}</span>
                </div>

                <!-- Activity Log Section (Collapsible) -->
                ${activityLogHtml}
            </div>

            <!-- Expand/Collapse Button (Bottom) -->
            <button onclick="toggleResourceExpand(${resource.id}); event.stopPropagation();"
                    class="expand-btn bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-500 dark:text-gray-400 transition-colors"
                    title="${isExpanded ? 'Hide Activity Log' : 'Show Activity Log'}">
                <i class="fas fa-circle-chevron-${isExpanded ? 'up' : 'down'}"></i>
                <span class="ml-1 text-xs">Activity Log ${resource.recordings.length > 0 ? `(${resource.recordings.length})` : ''}</span>
            </button>
        `;

        return card;
    }

    function createActivityLogHtml(resource, isExpanded) {
        const recordingsHtml = resource.recordings.length === 0 
            ? '<div class="text-xs text-gray-500 text-center py-2">No activity recorded</div>'
            : resource.recordings.slice(-10).reverse().map((rec, idx) => {
                const actualIdx = resource.recordings.length - 1 - idx;
                return createRecordingItemHtml(resource.id, rec, actualIdx);
            }).join('');

        return `
            <div class="activity-log ${isExpanded ? 'expanded' : ''} mt-3 border-t border-gray-200 dark:border-gray-700 pt-2" onclick="event.stopPropagation();">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-sm font-medium">Activity Log</span>
                    ${resource.isRecording ? 
                        `<span class="text-xs text-red-500 animate-pulse">
                            <i class="fas fa-circle mr-1"></i>${resource.recordingType === 'rx' ? 'RX' : 'TX'}
                        </span>` : ''}
                </div>
                <div class="space-y-1">
                    ${recordingsHtml}
                </div>
            </div>
        `;
    }

    function createRssiMeterHtml(level) {
        // level is 0-8, we show 5 bars
        let bars = '';
        for (let i = 0; i < 5; i++) {
            const height = 4 + (i * 2);
            const isActive = level > (i * 1.6);
            bars += `<div class="rssi-bar ${isActive ? '' : 'inactive'}" style="height: ${height}px;"></div>`;
        }
        return `<div class="rssi-meter">${bars}</div>`;
    }

    function createRecordingItemHtml(resourceId, recording, index) {
        const time = new Date(recording.timestamp).toLocaleTimeString();
        const typeIcon = recording.type === 'rx' ? 'fa-arrow-down text-green-500' : 'fa-arrow-up text-red-500';
        const callerDisplay = recording.callerId ? `<span class="caller-id ml-1">${recording.callerId}</span>` : '';

        return `
            <div class="flex items-center justify-between text-xs bg-gray-50 dark:bg-gray-700 rounded p-2">
                <span class="flex items-center space-x-1 flex-1 min-w-0">
                    <i class="fas ${typeIcon}"></i>
                    <span class="truncate">${time} (${recording.duration})</span>
                    ${callerDisplay}
                </span>
                <div class="flex space-x-2 ml-2">
                    <button onclick="playRecording(${resourceId}, ${index}); event.stopPropagation();" 
                            class="text-primary hover:text-primary/80" title="Play">
                        <i class="fas fa-play"></i>
                    </button>
                    <button onclick="saveRecording(${resourceId}, ${index}); event.stopPropagation();" 
                            class="text-blue-500 hover:text-blue-700" title="Save as WAV">
                        <i class="fas fa-download"></i>
                    </button>
                    <button onclick="deleteRecording(${resourceId}, ${index}); event.stopPropagation();" 
                            class="text-red-500 hover:text-red-700" title="Delete">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // ============================================================================
    // RESOURCE CONTROLS
    // ============================================================================

    function toggleResourceSelection(id) {
        const resource = resources.find(r => r.id === id);
        if (!resource) return;

        const nodes = resourceAudioNodes.get(id);

        if (resource.selected) {
            // Deselect
            resource.selected = false;
            resource.volume = nodes ? nodes.previousVolume : unselectedVolume;
            if (nodes && audioContext) {
                nodes.pannerNode.pan.linearRampToValueAtTime(1, audioContext.currentTime + 0.05);
                
                // If muting is enabled and resource is receiving, mute it now that it's unselected
                if (isMuted && resource.busy && resource.recordingType === 'rx') {
                    nodes.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.05);
                }
            }
            
            // Reset VU meter if this resource was receiving and no other selected resource is receiving
            if (resource.busy && resource.recordingType === 'rx') {
                const otherSelectedReceiving = resources.some(r => 
                    r.id !== id && r.selected && r.busy && r.recordingType === 'rx'
                );
                if (!otherSelectedReceiving) {
                    resetVuMeter();
                }
            }
        } else {
            // Select
            if (nodes) {
                nodes.previousVolume = resource.volume;
            }
            resource.selected = true;
            resource.volume = selectedVolume;
            if (nodes && audioContext) {
                nodes.pannerNode.pan.linearRampToValueAtTime(-1, audioContext.currentTime + 0.05);
                
                // If resource is receiving and was muted (because isMuted was on), unmute it now
                if (resource.busy && resource.recordingType === 'rx') {
                    nodes.gainNode.gain.linearRampToValueAtTime(volumeToGain(selectedVolume), audioContext.currentTime + 0.05);
                }
            }
        }

        renderResources();
    }

    function toggleResourceExpand(id) {
        if (expandedResources.has(id)) {
            expandedResources.delete(id);
        } else {
            expandedResources.add(id);
        }
        renderResources();
    }

    function toggleResourcePatch(id) {
        const resource = resources.find(r => r.id === id);
        if (!resource) return;

        if (resource.patch) {
            // Remove from patch
            resource.patch = false;
            patchedResources = patchedResources.filter(pId => pId !== id);
        } else {
            // Add to patch (max 2 resources)
            if (patchedResources.length >= 2) {
                playBonkSound();
                return;
            }
            resource.patch = true;
            patchedResources.push(id);
        }

        // End any active rebroadcast if patch configuration changes
        // This ensures PTT_UP is sent to stop transmission on the target resource
        if (patchedResources.length !== 2) {
            if (rebroadcastState.targetId) {
                console.log(`Patch broken - ending active rebroadcast on resource ${rebroadcastState.targetId}`);
                endRebroadcast();
            } else {
                rebroadcastState = { sourceId: null, targetId: null };
            }
        }

        renderResources();
    }

    function toggleResourcePriority(id) {
        const resource = resources.find(r => r.id === id);
        if (!resource) return;

        resource.priority = !resource.priority;

        if (resource.priority) {
            startPriorityTimer(id);
        } else {
            stopPriorityTimer(id);
        }

        renderResources();
    }

    function startPriorityTimer(resourceId) {
        // Play immediately
        initAudioContext().then(() => {
            playPriorityTone(resourceId);
        });

        // Set up 10-second interval
        const interval = setInterval(() => {
            const resource = resources.find(r => r.id === resourceId);
            if (!resource || !resource.priority) {
                stopPriorityTimer(resourceId);
                return;
            }

            // Check if resource is currently receiving
            if (resource.busy && resource.recordingType === 'rx') {
                // Queue to play when RX ends
                priorityQueued.set(resourceId, true);
            } else {
                playPriorityTone(resourceId);
            }
        }, 10000);

        priorityIntervals.set(resourceId, interval);
    }

    function stopPriorityTimer(resourceId) {
        if (priorityIntervals.has(resourceId)) {
            clearInterval(priorityIntervals.get(resourceId));
            priorityIntervals.delete(resourceId);
        }
        priorityQueued.delete(resourceId);
    }

    function checkQueuedPriorityTone(resourceId) {
        // Called when RX ends - check if priority tone was queued
        if (priorityQueued.get(resourceId)) {
            priorityQueued.delete(resourceId);
            playPriorityTone(resourceId);
        }
    }

    function updateResourceVolume(id, volume) {
        const resource = resources.find(r => r.id === id);
        if (!resource) return;

        resource.volume = parseInt(volume);

        // Update previousVolume if not selected
        if (!resource.selected) {
            const nodes = resourceAudioNodes.get(id);
            if (nodes) {
                nodes.previousVolume = resource.volume;
            }
        }

        // Apply volume if currently receiving
        if (resource.busy && resource.recordingType === 'rx') {
            const nodes = resourceAudioNodes.get(id);
            if (nodes && audioContext) {
                const targetVolume = isMuted && !resource.selected ? 0 : resource.volume;
                nodes.gainNode.gain.linearRampToValueAtTime(volumeToGain(targetVolume), audioContext.currentTime + 0.05);
            }
        }
    }

    // ============================================================================
    // MUTING
    // ============================================================================

    function toggleMute() {
        isMuted = !isMuted;

        const muteIcon = document.getElementById('muteIcon');
        const muteBtn = document.getElementById('muteBtn');

        if (muteTimeout) {
            clearTimeout(muteTimeout);
            muteTimeout = null;
        }

        if (isMuted) {
            muteIcon.className = 'fas fa-volume-mute';
            muteBtn.classList.add('bg-red-500');
            muteBtn.classList.remove('bg-gray-500');

            // Auto-unmute after 15 seconds
            muteTimeout = setTimeout(() => {
                if (isMuted) {
                    toggleMute();
                }
            }, 15000);
        } else {
            muteIcon.className = 'fas fa-volume-up';
            muteBtn.classList.remove('bg-red-500');
            muteBtn.classList.add('bg-gray-500');
        }

        // Apply mute to unselected resources that are receiving
        resources.forEach(resource => {
            if (!resource.selected && resource.busy && resource.recordingType === 'rx') {
                const nodes = resourceAudioNodes.get(resource.id);
                if (nodes && audioContext) {
                    const targetVolume = isMuted ? 0 : resource.volume;
                    nodes.gainNode.gain.linearRampToValueAtTime(volumeToGain(targetVolume), audioContext.currentTime + 0.05);
                }
            }
        });
    }

    // ============================================================================
    // STACK LIGHT FUNCTIONS
    // ============================================================================

    function toggleStackLightSettings() {
        const toggle = document.getElementById('stackLightToggle');
        const settingsBtn = document.getElementById('stackLightSettingsBtn');
        stackLightEnabled = toggle.checked;
        
        if (stackLightEnabled) {
            settingsBtn.classList.remove('hidden');
        } else {
            settingsBtn.classList.add('hidden');
            disconnectStackLight();
        }
        saveToLocalStorage();
    }

    async function connectStackLight() {
        try {
            stackLightPort = await navigator.serial.requestPort();
            await stackLightPort.open({ baudRate: 115200 });
            
            stackLightWriter = stackLightPort.writable.getWriter();
            stackLightReader = stackLightPort.readable.getReader();
            stackLightConnected = true;
            
            // Update UI
            document.getElementById('stackLightConnectionInfo').innerHTML = 
                '<span class="text-green-500"><i class="fas fa-check-circle mr-1"></i>Connected</span>';
            
            // Start polling for status requests from the stack light
            startStackLightPolling();
            
            // Start listening for poll requests from stack light
            readStackLightSerial();
            
            console.log('Stack light connected');
        } catch (error) {
            console.error('Stack light connection failed:', error);
            document.getElementById('stackLightConnectionInfo').innerHTML = 
                '<span class="text-red-500"><i class="fas fa-exclamation-circle mr-1"></i>Connection failed</span>';
        }
    }

    function disconnectStackLight() {
        if (stackLightPollInterval) {
            clearInterval(stackLightPollInterval);
            stackLightPollInterval = null;
        }
        
        if (stackLightWriter) {
            stackLightWriter.releaseLock();
            stackLightWriter = null;
        }
        if (stackLightReader) {
            stackLightReader.cancel();
            stackLightReader.releaseLock();
            stackLightReader = null;
        }
        if (stackLightPort) {
            stackLightPort.close().catch(() => {});
            stackLightPort = null;
        }
        
        stackLightConnected = false;
        
        const infoEl = document.getElementById('stackLightConnectionInfo');
        if (infoEl) {
            infoEl.innerHTML = '<span class="text-gray-500">Status: Not Connected</span>';
        }
    }

    function startStackLightPolling() {
        // Clear any existing interval
        if (stackLightPollInterval) {
            clearInterval(stackLightPollInterval);
        }
        
        // No need to poll from console side - the stack light polls us
        // We just need to be ready to respond
    }

    async function readStackLightSerial() {
        if (!stackLightReader) return;
        
        try {
            while (stackLightConnected) {
                const { value, done } = await stackLightReader.read();
                if (done) break;
                
                // Debug: log received bytes
                console.log('Stack light received bytes:', Array.from(value).map(b => '0x' + b.toString(16).padStart(2, '0')));
                
                // Check for status request from stack light
                for (let byte of value) {
                    if (byte === STACK_LIGHT_CMD_STATUS_REQUEST) {
                        // Stack light is asking for current status - send it
                        console.log('Stack light poll received (0xFF), sending status...');
                        sendStackLightStatus();
                    }
                }
            }
        } catch (error) {
            if (stackLightConnected) {
                console.error('Stack light read error:', error);
                disconnectStackLight();
            }
        }
    }

    function getStackLightState() {
        // Green: Receiving on any selected resource
        let greenState = STACK_LIGHT_OFF;
        const anySelectedReceiving = resources.some(r => 
            r.selected && r.busy && r.recordingType === 'rx'
        );
        if (anySelectedReceiving) {
            greenState = STACK_LIGHT_SOLID;
        }
        
        // Yellow: Any transmitting (voice, alert tones, 2-tone, DTMF page)
        // Exclude priority tone - that's red only, not yellow
        let yellowState = STACK_LIGHT_OFF;
        const anyResourceTransmitting = resources.some(r => 
            r.busy && r.recordingType === 'tx'
        );
        // Only show yellow if NOT in priority tone mode
        if (!priorityTonePlaying && (activeTxIds.length > 0 || isTransmittingPages || alertTone1Playing || alertTone2Playing || anyResourceTransmitting)) {
            yellowState = STACK_LIGHT_SOLID;
        }
        
        // Red: Unacknowledged emergency (solid) or priority tone playing (on during tone)
        let redState = STACK_LIGHT_OFF;
        const unacknowledgedCount = emergencyEvents.filter(e => !e.acknowledged).length;
        if (unacknowledgedCount > 0) {
            redState = STACK_LIGHT_SOLID;  // Emergency overrides everything
        } else if (priorityTonePlaying) {
            redState = STACK_LIGHT_SOLID;  // On while tone is playing
        }
        
        return { green: greenState, yellow: yellowState, red: redState };
    }

    async function sendStackLightStatus() {
        if (!stackLightConnected || !stackLightWriter) return;
        
        try {
            const state = getStackLightState();
            const data = new Uint8Array([
                STACK_LIGHT_CMD_STATUS_RESPONSE,
                state.green,
                state.yellow,
                state.red
            ]);
            console.log('Sending to stack light:', Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')), 
                        '(G:', state.green, 'Y:', state.yellow, 'R:', state.red, ')');
            await stackLightWriter.write(data);
        } catch (error) {
            console.error('Stack light write error:', error);
        }
    }

    // Call this whenever state changes that affects the stack light
    function updateStackLight() {
        if (stackLightConnected) {
            sendStackLightStatus();
        }
    }

    // ============================================================================
    // TRANSMIT FUNCTIONS
    // ============================================================================

    function muteUnselectedDuringTx(muting) {
        resources.forEach(resource => {
            if (!resource.selected && resource.busy && resource.recordingType === 'rx') {
                const nodes = resourceAudioNodes.get(resource.id);
                if (nodes && audioContext) {
                    const targetVolume = muting ? 0 : (isMuted ? 0 : resource.volume);
                    nodes.gainNode.gain.linearRampToValueAtTime(volumeToGain(targetVolume), audioContext.currentTime + 0.05);
                }
            }
        });
    }

    async function startGeneralTransmit() {
        if (activeTxIds.length > 0 || isTransmittingPages) return;

        await initAudioContext();

        // Get selected and connected resources
        const selectedResources = resources.filter(r => r.selected && r.isConnected);

        if (selectedResources.length === 0) {
            playBonkSound();
            return;
        }

        // PATCH CHECK: If a rebroadcast is in progress, deny general transmit
        if (rebroadcastState.sourceId !== null) {
            console.log('General TX denied - patch rebroadcast in progress');
            playBonkSound();
            return;
        }

        // Separate available and busy resources
        const available = selectedResources.filter(r => !r.busy);
        const busy = selectedResources.filter(r => r.busy);

        if (available.length === 0) {
            playBonkSound();
            return;
        }

        // Bonk if some are busy but continue with available
        if (busy.length > 0) {
            playBonkSound();
        }

        playTalkPermitTone();
        muteUnselectedDuringTx(true);
        txPacketCount = 0; // Reset packet counter

        // Track pending (busy) resources
        pendingTxIds = busy.map(r => r.id);

        // Start transmitting on available resources
        for (const resource of available) {
            activeTxIds.push(resource.id);
            resource.busy = true;
            resource.recordingType = 'tx';

            console.log(`Starting TX on resource ${resource.id} (${resource.name})`);
            await sendGroupCommand(resource);
            console.log(`Sending PTT_DOWN to resource ${resource.id}`);
            await sendSerialPacket(COMMAND_HOST_PTT_DOWN, null, resource.id);
            
            // Connect txMergerNode to recording destination for TX recording
            const nodes = resourceAudioNodes.get(resource.id);
            if (nodes && nodes.recordingDestination && txMergerNode) {
                try {
                    txMergerNode.connect(nodes.recordingDestination);
                    nodes.txRecordingConnected = true;
                } catch (e) {
                    console.warn('Failed to connect TX to recording:', e);
                }
            }
            
            startRecording(resource.id, 'tx');
        }

        // Wait for radio to key up and talk permit tone to complete (150ms)
        // This prevents the beginning of TX audio from being clipped
        await delay(150);

        // Send Console ID at start if configured
        if (consoleIdEnabled && consoleIdString && (consoleIdTiming === 'start' || consoleIdTiming === 'both')) {
            await transmitDTMFString(consoleIdString);
            await delay(50);
        }

        renderResources();
        document.getElementById('generalTransmitBtn').classList.add('transmit-active');
        
        // Update stack light for TX state
        updateStackLight();
    }

    async function stopTransmit() {
        if (activeTxIds.length === 0) return;

        // Send Console ID at end if configured
        if (consoleIdEnabled && consoleIdString && (consoleIdTiming === 'end' || consoleIdTiming === 'both')) {
            try {
                await transmitDTMFString(consoleIdString);
                await delay(100);
            } catch (e) {
                console.warn('Failed to send console ID:', e);
            }
        }

        muteUnselectedDuringTx(false);
        
        // Unmute microphone after paging/tone transmission
        unmuteMicForTones();

        // Stop all active transmissions - use timeout to prevent hanging
        const stopPromises = [...activeTxIds].map(async (id) => {
            const resource = resources.find(r => r.id === id);
            if (resource) {
                try {
                    // Only try to send PTT_UP if still connected
                    if (resource.isConnected && resource.writer) {
                        await Promise.race([
                            sendSerialPacket(COMMAND_HOST_PTT_UP, null, id),
                            delay(500) // 500ms timeout
                        ]);
                    }
                } catch (e) {
                    console.warn(`Failed to send PTT_UP to resource ${id}:`, e);
                }
                
                // Disconnect txMergerNode from recording destination
                const nodes = resourceAudioNodes.get(id);
                if (nodes && nodes.txRecordingConnected && txMergerNode) {
                    try {
                        txMergerNode.disconnect(nodes.recordingDestination);
                        nodes.txRecordingConnected = false;
                    } catch (e) {
                        // May already be disconnected
                    }
                }
                
                stopRecording(id);
                resource.busy = false;
                resource.recordingType = null;
            }
        });

        // Wait for all stop operations with overall timeout
        try {
            await Promise.race([
                Promise.all(stopPromises),
                delay(1000) // 1 second overall timeout
            ]);
        } catch (e) {
            console.warn('Timeout stopping transmissions:', e);
        }

        activeTxIds = [];
        pendingTxIds = [];
        isTransmittingPages = false;

        // Reset encoder state for next transmission
        if (opusEncoder && opusEncoder.reset) {
            opusEncoder.reset();
        }

        // Stop alert tones if playing
        if (alertTone1Playing) stopAlertTone1();
        if (alertTone2Playing) stopAlertTone2();

        // Reset VU meter
        resetVuMeter();

        renderResources();
        document.getElementById('generalTransmitBtn').classList.remove('transmit-active');
        
        // Update stack light for TX state
        updateStackLight();
        
        // Check for any queued priority tones
        setTimeout(() => {
            resources.forEach(resource => {
                if (resource.priorityToneQueued && resource.priority && resource.isConnected) {
                    resource.priorityToneQueued = false;
                    playPriorityTone(resource.id);
                }
            });
        }, 100); // Small delay to ensure TX is fully stopped
    }

    async function startInstantTransmit(resourceId) {
        if (activeTxIds.length > 0 || isTransmittingPages) return;

        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.isConnected) {
            playBonkSound();
            return;
        }

        await initAudioContext();

        // If resource is receiving, stop it first
        if (resource.busy && resource.recordingType === 'rx') {
            endRxSession(resourceId);
        }
        
        // PATCH FIX: If this resource is currently the target of a rebroadcast, stop it
        if (rebroadcastState.targetId === resourceId) {
            console.log('Instant TX interrupting patch rebroadcast on resource', resourceId);
            await endRebroadcast();
        }
        
        // PATCH FIX: If this resource is the source of a rebroadcast, also stop it
        // (can't receive and transmit at the same time)
        if (rebroadcastState.sourceId === resourceId) {
            console.log('Instant TX interrupting patch source on resource', resourceId);
            await endRebroadcast();
        }

        muteUnselectedDuringTx(true);
        playTalkPermitTone();

        activeTxIds = [resourceId];
        resource.busy = true;
        resource.recordingType = 'tx';

        await sendGroupCommand(resource);
        await sendSerialPacket(COMMAND_HOST_PTT_DOWN, null, resourceId);
        
        // Connect txMergerNode to recording destination for TX recording
        const nodes = resourceAudioNodes.get(resourceId);
        if (nodes && nodes.recordingDestination && txMergerNode) {
            try {
                txMergerNode.connect(nodes.recordingDestination);
                nodes.txRecordingConnected = true;
            } catch (e) {
                console.warn('Failed to connect TX to recording:', e);
            }
        }
        
        startRecording(resourceId, 'tx');

        // Wait for radio to key up
        await delay(150);

        // Send Console ID at start if configured
        if (consoleIdEnabled && consoleIdString && (consoleIdTiming === 'start' || consoleIdTiming === 'both')) {
            await transmitDTMFString(consoleIdString);
        }

        renderResources();
        
        // Update stack light for TX state
        updateStackLight();
    }

    // ============================================================================
    // ALERT TONES
    // ============================================================================

    async function startAlertTone1() {
        if (alertTone1Playing || alertTone2Playing) return;
        if (activeTxIds.length === 0 && !isTransmittingPages) {
            // Need to start transmit first
            await startPagingTransmit();
            if (activeTxIds.length === 0) return;
        }

        alertTone1Playing = true;
        document.getElementById('alertTone1Btn').classList.add('alert-tone-active');

        // Continuous 1000Hz tone
        if (audioContext) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            // Connect to both master (local playback) AND TX pipeline
            gainNode.connect(masterGainNode);
            if (txMergerNode) {
                gainNode.connect(txMergerNode);
            }

            oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);

            oscillator.start();
            alertTone1Oscillator = { oscillator, gainNode };
        }
        
        // Update stack light for TX state
        updateStackLight();
    }

    async function stopAlertTone1() {
        if (!alertTone1Playing) return;

        alertTone1Playing = false;
        document.getElementById('alertTone1Btn').classList.remove('alert-tone-active');

        if (alertTone1Oscillator) {
            alertTone1Oscillator.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.05);
            setTimeout(() => {
                try {
                    alertTone1Oscillator.oscillator.stop();
                    alertTone1Oscillator.oscillator.disconnect();
                    alertTone1Oscillator.gainNode.disconnect();
                } catch (e) {}
                alertTone1Oscillator = null;
            }, 100);
        }

        // Stop transmission if this alert tone started it
        if (isTransmittingPages && !alertTone2Playing) {
            await stopTransmit();
        }
        
        // Update stack light for TX state
        updateStackLight();
    }

    async function startAlertTone2() {
        if (alertTone1Playing || alertTone2Playing) return;
        if (activeTxIds.length === 0 && !isTransmittingPages) {
            await startPagingTransmit();
            if (activeTxIds.length === 0) return;
        }

        alertTone2Playing = true;
        document.getElementById('alertTone2Btn').classList.add('alert-tone-active');

        // Alternating 1500Hz / 900Hz
        let isHigh = true;
        const playAlternating = () => {
            if (!alertTone2Playing) return;
            // Pass forTx=true to route through TX pipeline
            generateTone(isHigh ? 1500 : 900, 0.25, 0.25, 'sine', true);
            isHigh = !isHigh;
        };

        playAlternating();
        alertTone2Interval = setInterval(playAlternating, 250);
        
        // Update stack light for TX state
        updateStackLight();
    }

    async function stopAlertTone2() {
        if (!alertTone2Playing) return;

        alertTone2Playing = false;
        document.getElementById('alertTone2Btn').classList.remove('alert-tone-active');

        if (alertTone2Interval) {
            clearInterval(alertTone2Interval);
            alertTone2Interval = null;
        }

        // Stop transmission if this alert tone started it
        if (isTransmittingPages && !alertTone1Playing) {
            await stopTransmit();
        }
        
        // Update stack light for TX state
        updateStackLight();
    }

    // ============================================================================
    // PAGING SYSTEM
    // ============================================================================

    function renderPages() {
        const grid = document.getElementById('pagesGrid');
        grid.innerHTML = '';

        pages.forEach(page => {
            grid.appendChild(createPageCard(page));
        });
    }

    function createPageCard(page) {
        const card = document.createElement('div');
        const isStacked = stackedPages.includes(page.id);

        card.className = `bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-3 text-center transition-all cursor-pointer hover:shadow-md ${isStacked ? 'page-stacked' : ''}`;

        // All pages use green pager icon
        card.innerHTML = `
            <div class="w-12 h-12 bg-green-500 text-white rounded-lg mb-2 mx-auto flex items-center justify-center">
                <i class="fas fa-pager"></i>
            </div>
            <div class="text-sm font-medium mb-2 truncate" title="${escapeHtml(page.name)}">${escapeHtml(page.name)}</div>
            <div class="text-xs text-gray-500 mb-2">${page.type === 'dtmf' ? 'DTMF' : '2-Tone'}</div>
            <div class="flex justify-center space-x-1">
                <button onclick="event.stopPropagation(); editPage(${page.id})" 
                        class="p-1 text-gray-500 hover:text-primary rounded transition-colors" title="Edit">
                    <i class="fas fa-edit text-xs"></i>
                </button>
                <button onclick="event.stopPropagation(); confirmDeletePage(${page.id})" 
                        class="p-1 text-gray-500 hover:text-red-500 rounded transition-colors" title="Delete">
                    <i class="fas fa-trash text-xs"></i>
                </button>
            </div>
        `;

        // Page press handlers
        card.addEventListener('mousedown', (e) => {
            if (e.target.closest('button')) return;
            handlePagePressStart(page.id);
        });
        card.addEventListener('mouseup', (e) => {
            if (e.target.closest('button')) return;
            handlePagePressEnd(page.id);
        });
        card.addEventListener('mouseleave', () => handlePagePressCancel());
        card.addEventListener('touchstart', (e) => {
            if (e.target.closest('button')) return;
            e.preventDefault();
            handlePagePressStart(page.id);
        }, { passive: false });
        card.addEventListener('touchend', (e) => {
            if (e.target.closest('button')) return;
            e.preventDefault();
            handlePagePressEnd(page.id);
        }, { passive: false });

        return card;
    }

    let currentPressedPageId = null;

    function handlePagePressStart(pageId) {
        isLongPress = false;
        currentPressedPageId = pageId;

        pagePressTimer = setTimeout(() => {
            isLongPress = true;
            togglePageStack(pageId);
        }, 500);
    }

    function handlePagePressEnd(pageId) {
        if (pagePressTimer) {
            clearTimeout(pagePressTimer);
            pagePressTimer = null;
        }
        
        // If it wasn't a long press, execute the page immediately (single click)
        if (!isLongPress && currentPressedPageId === pageId) {
            executeSinglePage(pageId);
        }
        currentPressedPageId = null;
    }

    function handlePagePressCancel() {
        if (pagePressTimer) {
            clearTimeout(pagePressTimer);
            pagePressTimer = null;
        }
        currentPressedPageId = null;
    }

    async function executeSinglePage(pageId) {
        const page = pages.find(p => p.id === pageId);
        if (!page) return;

        // Get selected connected resources
        const selectedResources = resources.filter(r => r.selected && r.isConnected && !r.busy);
        if (selectedResources.length === 0) {
            playBonkSound();
            console.log(`Page "${page.name}" failed - no resources available`);
            return;
        }

        // Reset cancel flag
        pagingCancelled = false;

        // Start transmit on selected resources
        const txIds = await startPagingTransmit();
        if (!txIds || txIds.length === 0) return;

        // Update button to show cancel state
        const stackBtn = document.getElementById('transmitStackBtn');
        const stackIcon = document.getElementById('transmitStackIcon');
        stackBtn.classList.add('transmit-active');
        stackBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
        stackBtn.classList.add('bg-red-500', 'hover:bg-red-600');
        stackIcon.innerHTML = '<i class="fas fa-stop"></i> Cancel';

        console.log(`Transmitting page: ${page.name}`);

        // Execute the page
        if (page.type === 'dtmf') {
            await transmitDTMFString(page.dtmfString);
        } else {
            await transmit2Tone(page.firstToneFreq, page.secondToneFreq);
        }

        // Stop transmit
        await stopTransmit();
        resetPagingButton();
    }

    function togglePageStack(pageId) {
        const idx = stackedPages.indexOf(pageId);
        if (idx > -1) {
            stackedPages.splice(idx, 1);
        } else {
            stackedPages.push(pageId);
        }
        renderPages();
    }

    async function startPagingTransmit() {
        if (activeTxIds.length > 0) return activeTxIds;

        await initAudioContext();

        const selectedResources = resources.filter(r => r.selected && r.isConnected && !r.busy);

        if (selectedResources.length === 0) {
            playBonkSound();
            return null;
        }

        muteUnselectedDuringTx(true);
        isTransmittingPages = true;
        
        // Mute microphone during paging - only tones should go out
        muteMicForTones();

        for (const resource of selectedResources) {
            activeTxIds.push(resource.id);
            resource.busy = true;
            resource.recordingType = 'tx';

            await sendGroupCommand(resource);
            await sendSerialPacket(COMMAND_HOST_PTT_DOWN, null, resource.id);
        }

        // Wait for radio to key up (150ms) to prevent tone clipping
        await delay(150);

        renderResources();
        
        // Update stack light for TX state
        updateStackLight();
        
        return activeTxIds;
    }

    async function transmitStackedPages() {
        if (stackedPages.length === 0) {
            playBonkSound();
            return;
        }

        // Reset cancel flag
        pagingCancelled = false;

        const txIds = await startPagingTransmit();
        if (!txIds || txIds.length === 0) return;

        // Update button to show cancel state
        const stackBtn = document.getElementById('transmitStackBtn');
        const stackIcon = document.getElementById('transmitStackIcon');
        stackBtn.classList.add('transmit-active');
        stackBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
        stackBtn.classList.add('bg-red-500', 'hover:bg-red-600');
        stackIcon.innerHTML = '<i class="fas fa-stop"></i> Cancel';

        // Transmit each stacked page
        for (const pageId of stackedPages) {
            if (pagingCancelled || !isTransmittingPages) break;

            const page = pages.find(p => p.id === pageId);
            if (!page) continue;

            if (page.type === 'dtmf') {
                await transmitDTMFString(page.dtmfString);
            } else if (page.type === '2tone') {
                await transmit2Tone(page.firstToneFreq, page.secondToneFreq);
            }

            // Brief pause between pages (with cancel check)
            for (let i = 0; i < 5; i++) {
                if (pagingCancelled) break;
                await delay(100);
            }
        }

        // Clear stack after transmission
        stackedPages = [];
        renderPages();

        await stopTransmit();
        resetPagingButton();
    }

    function cancelPaging() {
        console.log('Cancelling paging transmission...');
        
        // Set cancel flag to exit any loops
        pagingCancelled = true;
        isTransmittingPages = false;
        
        // Stop all active paging oscillators immediately
        for (const { oscillator, gainNode } of activePagingOscillators) {
            try {
                // Fade out quickly to prevent click
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.01);
                oscillator.stop(audioContext.currentTime + 0.015);
            } catch (e) {
                // Oscillator may already be stopped
            }
        }
        activePagingOscillators = [];
        
        stackedPages = [];
        renderPages();
        stopTransmit();
        resetPagingButton();
    }

    function resetPagingButton() {
        const stackBtn = document.getElementById('transmitStackBtn');
        const stackIcon = document.getElementById('transmitStackIcon');
        stackBtn.classList.remove('transmit-active');
        stackBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
        stackBtn.classList.add('bg-green-500', 'hover:bg-green-600');
        stackIcon.innerHTML = '<i class="fas fa-pager"></i><i class="fas fa-tower-cell ml-1"></i>';
    }

    // ============================================================================
    // RECORDING SYSTEM (WAV Export)
    // ============================================================================

    function startRecording(resourceId, type) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        const nodes = resourceAudioNodes.get(resourceId);
        if (!nodes || !nodes.recordingDestination) return;

        try {
            const mediaRecorder = new MediaRecorder(nodes.recordingDestination.stream, {
                mimeType: 'audio/webm;codecs=opus'
            });

            const chunks = [];
            const startTime = Date.now();

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    chunks.push(e.data);
                }
            };

            mediaRecorder.onstop = () => {
                if (chunks.length > 0) {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    const duration = ((Date.now() - startTime) / 1000).toFixed(1) + 's';

                    // Get caller ID from decoder
                    const decoder = resourceDtmfDecoders.get(resourceId);
                    let callerId = null;
                    if (decoder && type === 'rx') {
                        // IMPORTANT: Capture the emergency flag BEFORE endTransmission() resets it
                        const alreadyTriggered = decoder.emergencyTriggeredThisSession;
                        
                        const dtmfResult = decoder.endTransmission();
                        
                        // Use allDigits as the primary source - it captures everything
                        // startId and endId are just window-based subsets
                        const detectedId = dtmfResult.allDigits || dtmfResult.startId || dtmfResult.endId;
                        
                        console.log('DTMF Result:', {
                            startId: dtmfResult.startId,
                            endId: dtmfResult.endId,
                            allDigits: dtmfResult.allDigits,
                            detectedId: detectedId,
                            emergencyEnabled: emergencyEnabled,
                            emergencyTriggerDtmf: emergencyTriggerDtmf,
                            triggerLength: emergencyTriggerDtmf ? emergencyTriggerDtmf.length : 0,
                            alreadyTriggeredImmediately: alreadyTriggered
                        });
                        
                        // Process DTMF through emergency check first, then alias resolution
                        if (detectedId) {
                            let displayId = detectedId;
                            let isEmergency = false;
                            
                            // Check for emergency trigger (if enabled and not already triggered)
                            // Log the check even if conditions aren't met
                            console.log('Emergency pre-check:', {
                                emergencyEnabled: emergencyEnabled,
                                hasTrigger: !!emergencyTriggerDtmf,
                                triggerValue: emergencyTriggerDtmf,
                                alreadyTriggered: alreadyTriggered
                            });
                            
                            if (emergencyEnabled && emergencyTriggerDtmf && emergencyTriggerDtmf.length > 0) {
                                // Check if detected DTMF contains the trigger string
                                const triggerIndex = detectedId.indexOf(emergencyTriggerDtmf);
                                console.log('Emergency check:', {
                                    triggerIndex: triggerIndex,
                                    triggerString: emergencyTriggerDtmf,
                                    inDetectedId: detectedId,
                                    found: triggerIndex !== -1
                                });
                                
                                if (triggerIndex !== -1) {
                                    isEmergency = true;
                                    if (alreadyTriggered) {
                                        console.log('🚨 EMERGENCY (already alerted immediately) 🚨');
                                    } else {
                                        console.log('🚨 EMERGENCY TRIGGERED! 🚨');
                                    }
                                    
                                    // Extract excess digits (digits beyond the trigger)
                                    const beforeTrigger = detectedId.substring(0, triggerIndex);
                                    const afterTrigger = detectedId.substring(triggerIndex + emergencyTriggerDtmf.length);
                                    const excessDigits = beforeTrigger + afterTrigger;
                                    
                                    console.log('Excess digits:', {
                                        beforeTrigger: beforeTrigger,
                                        afterTrigger: afterTrigger,
                                        excessDigits: excessDigits
                                    });
                                    
                                    // If there are excess digits, use those for caller ID
                                    // Otherwise, the caller ID will just be the emergency trigger
                                    if (excessDigits.length > 0) {
                                        displayId = excessDigits;
                                    } else {
                                        displayId = null; // No caller ID beyond the trigger
                                    }
                                }
                            } else {
                                console.log('Emergency check skipped:', {
                                    reason: !emergencyEnabled ? 'disabled' : !emergencyTriggerDtmf ? 'no trigger set' : 'trigger empty'
                                });
                            }
                            
                            // Resolve display ID through alias system
                            callerId = displayId ? resolveCallerId(displayId) : null;
                            
                            console.log('Final callerId:', callerId, 'isEmergency:', isEmergency);
                            
                            // Trigger emergency alert if detected AND not already triggered
                            if (isEmergency && !alreadyTriggered) {
                                triggerEmergency(resourceId, callerId || detectedId);
                            }
                        }
                    }

                    // Update current caller ID display
                    if (nodes) {
                        nodes.currentCallerId = callerId;
                        // Also update the persistent caller ID for display (fades after 10s)
                        if (callerId) {
                            nodes.lastCallerId = callerId;
                            nodes.lastCallerIdTime = Date.now();
                            // Schedule re-render to handle fade effect
                            setTimeout(() => renderResources(), 10500); // Refresh after fade completes
                        }
                    }

                    resource.recordings.push({
                        blob,
                        timestamp: startTime,
                        duration,
                        type,
                        callerId,
                        resourceName: resource.name
                    });

                    // Keep only last 20 recordings per resource
                    if (resource.recordings.length > 20) {
                        resource.recordings.shift();
                    }

                    renderResources();
                }
            };

            mediaRecorder.start(100); // Collect data every 100ms

            resource.isRecording = true;
            resource.recordingType = type;

            activeRecorders.set(resourceId, {
                recorder: mediaRecorder,
                startTime,
                type
            });

            // Start DTMF decoder for RX
            if (type === 'rx') {
                const decoder = resourceDtmfDecoders.get(resourceId);
                if (decoder) {
                    decoder.startTransmission();
                }
            }

        } catch (e) {
            console.error('Failed to start recording:', e);
        }
    }

    function stopRecording(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        const recorderData = activeRecorders.get(resourceId);

        if (recorderData && recorderData.recorder.state !== 'inactive') {
            recorderData.recorder.stop();
        }

        activeRecorders.delete(resourceId);

        if (resource) {
            resource.isRecording = false;
        }

        // Clear caller ID display after a delay
        const nodes = resourceAudioNodes.get(resourceId);
        if (nodes) {
            setTimeout(() => {
                nodes.currentCallerId = null;
                renderResources();
            }, 2000);
        }
    }

    function resolveCallerId(dtmfId) {
        if (!dtmfId || !aliasDecodingEnabled) return dtmfId;

        const alias = radioAliases.find(a => a.dtmfId === dtmfId);
        return alias ? alias.name : dtmfId;
    }

    function playRecording(resourceId, index) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.recordings[index]) return;

        const recording = resource.recordings[index];
        const audio = new Audio(URL.createObjectURL(recording.blob));
        audio.play();
    }

    async function saveRecording(resourceId, index) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.recordings[index]) return;

        const recording = resource.recordings[index];

        // Convert WebM to WAV
        const wavBlob = await convertToWav(recording.blob);

        // Generate filename
        const timestamp = new Date(recording.timestamp).toISOString().replace(/[:.]/g, '-');
        const callerId = recording.callerId || 'Unknown';
        const sanitizedResourceName = resource.name.replace(/[^a-zA-Z0-9]/g, '_');
        const sanitizedCallerId = callerId.replace(/[^a-zA-Z0-9]/g, '_');
        const filename = `recording-${sanitizedResourceName}-${sanitizedCallerId}-${timestamp}.wav`;

        // Download
        const url = URL.createObjectURL(wavBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async function convertToWav(webmBlob) {
        // Decode the WebM audio
        const arrayBuffer = await webmBlob.arrayBuffer();

        try {
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            return audioBufferToWav(audioBuffer);
        } catch (e) {
            console.error('Failed to decode audio:', e);
            // Return original blob if conversion fails
            return webmBlob;
        }
    }

    function audioBufferToWav(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const format = 1; // PCM
        const bitDepth = 16;

        const bytesPerSample = bitDepth / 8;
        const blockAlign = numChannels * bytesPerSample;

        const samples = audioBuffer.length;
        const dataSize = samples * blockAlign;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        // Write WAV header
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + dataSize, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true); // Subchunk1Size
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * blockAlign, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitDepth, true);
        writeString(view, 36, 'data');
        view.setUint32(40, dataSize, true);

        // Write audio data
        const channelData = [];
        for (let i = 0; i < numChannels; i++) {
            channelData.push(audioBuffer.getChannelData(i));
        }

        let offset = 44;
        for (let i = 0; i < samples; i++) {
            for (let ch = 0; ch < numChannels; ch++) {
                let sample = channelData[ch][i];
                // Clamp
                sample = Math.max(-1, Math.min(1, sample));
                // Convert to 16-bit
                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(offset, intSample, true);
                offset += 2;
            }
        }

        return new Blob([buffer], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    function deleteRecording(resourceId, index) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        showConfirmDialog(
            'Delete Recording',
            'Are you sure you want to delete this recording?',
            () => {
                resource.recordings.splice(index, 1);
                renderResources();
            }
        );
    }

    // ============================================================================
    // SERIAL COMMUNICATION
    // ============================================================================

    // Simple serial packet sending (no flow control - like v1)
    async function sendSerialPacket(command, data, resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.writer || !resource.isConnected) {
            // Only log warning for non-audio commands to avoid spam
            if (command !== COMMAND_HOST_TX_AUDIO) {
                console.warn(`Cannot send to resource ${resourceId}: disconnected`);
            }
            return;
        }

        // Handle data that might be an ArrayBuffer or Uint8Array
        let dataArray;
        if (data) {
            if (data instanceof ArrayBuffer) {
                dataArray = new Uint8Array(data);
            } else if (data instanceof Uint8Array) {
                dataArray = data;
            } else {
                dataArray = new Uint8Array(data);
            }
        }

        const dataLength = dataArray ? dataArray.length : 0;
        const packet = new Uint8Array(7 + dataLength);

        // Delimiter (0xDEADBEEF)
        packet.set(COMMAND_DELIMITER, 0);

        // Command
        packet[4] = command;

        // Length (little-endian)
        packet[5] = dataLength & 0xFF;
        packet[6] = (dataLength >> 8) & 0xFF;

        // Data
        if (dataArray) {
            packet.set(dataArray, 7);
        }

        try {
            await resource.writer.write(packet);
        } catch (e) {
            console.error(`Failed to send packet to resource ${resourceId}:`, e);
        }
    }

    // Send binary GROUP command (COMMAND_HOST_GROUP = 0x03)
    // Format: { bw: uint8, freq_tx: float32, freq_rx: float32, ctcss_tx: uint8, squelch: uint8, ctcss_rx: uint8 }
    async function sendGroupCommand(resource) {
        const paramBuffer = new ArrayBuffer(12);
        const view = new DataView(paramBuffer);
        
        const freq_rx = resource.frequency;
        const freq_tx = (resource.mode === 'half-duplex' && resource.transmitFrequency) 
            ? resource.transmitFrequency 
            : resource.frequency;
        
        // Get CTCSS index (0 = no tone/CSQ)
        const ctcssIndex = resource.toneType === 'ctcss' && resource.ctcssTone 
            ? getCtcssIndex(resource.ctcssTone) 
            : 0;
        
        const squelch = resource.squelchLevel || 1; // Default to 1
        
        // Bandwidth: 0 = narrow (12.5kHz), 1 = wide (25kHz)
        const bandwidth = resource.bandwidth === 'wide' ? 1 : 0;
        
        // Build binary struct
        view.setUint8(0, bandwidth);                // bw: 0 = narrow, 1 = wide
        view.setFloat32(1, freq_tx, true);          // freq_tx (little-endian)
        view.setFloat32(5, freq_rx, true);          // freq_rx (little-endian)
        view.setUint8(9, ctcssIndex);               // ctcss_tx
        view.setUint8(10, squelch);                 // squelch (0-8)
        view.setUint8(11, ctcssIndex);              // ctcss_rx
        
        console.log(`GROUP cmd [Resource ${resource.id}]: TX=${freq_tx}MHz, RX=${freq_rx}MHz, CTCSS=${ctcssIndex}, SQ=${squelch}, BW=${bandwidth === 0 ? 'narrow' : 'wide'}`);
        
        await sendSerialPacket(COMMAND_HOST_GROUP, paramBuffer, resource.id);
    }

    // Send CONFIG command (COMMAND_HOST_CONFIG = 0x06)
    // This triggers the ESP32 to initialize the SA818 module and send back VERSION
    // Format: { isHigh: bool (1 byte) }
    async function sendConfigCommand(resource) {
        const paramBuffer = new ArrayBuffer(1);
        const view = new DataView(paramBuffer);
        view.setUint8(0, resource.txPower === 'high' ? 1 : 0);
        console.log(`CONFIG cmd [Resource ${resource.id}]: Initializing SA818 module...`);
        await sendSerialPacket(COMMAND_HOST_CONFIG, paramBuffer, resource.id);
    }

    // Send High/Low power command
    async function sendPowerCommand(resource) {
        const paramBuffer = new ArrayBuffer(1);
        const view = new DataView(paramBuffer);
        view.setUint8(0, resource.txPower === 'high' ? 1 : 0);
        await sendSerialPacket(COMMAND_HOST_HL, paramBuffer, resource.id);
    }

    async function connectResource() {
        const resourceIdStr = document.getElementById('editingResourceId').value;
        if (!resourceIdStr) {
            document.getElementById('resourceConnectionInfo').innerHTML = 
                '<span class="text-red-500">Save resource first before connecting</span>';
            return;
        }

        const resourceId = parseInt(resourceIdStr);
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        if (!('serial' in navigator)) {
            document.getElementById('resourceConnectionInfo').innerHTML = 
                '<span class="text-red-500">Web Serial API not supported in this browser</span>';
            return;
        }

        const infoEl = document.getElementById('resourceConnectionInfo');
        infoEl.innerHTML = '<span class="text-yellow-500"><i class="fas fa-spinner fa-spin mr-1"></i>Connecting...</span>';

        try {
            // Disconnect existing connection
            if (resource.port) {
                await disconnectResource(resourceId);
            }

            const port = await navigator.serial.requestPort();
            // Use larger buffer to prevent overruns from ESP32 flooding data
            await port.open({ baudRate: 115200, bufferSize: 262144 }); // 256KB buffer

            resource.port = port;
            resource.writer = port.writable.getWriter();
            resource.reader = port.readable.getReader();
            resource.readBuffer = new Uint8Array();
            resource.readState = 'delimiter';
            resource.isConnected = true;
            resource.overrunCount = 0; // Reset overrun counter

            // Send STOP command to ensure ESP32 stops any current operation
            console.log('Sending STOP commands to ESP32...');
            await sendSerialPacket(COMMAND_HOST_STOP, null, resourceId);
            await delay(100);
            await sendSerialPacket(COMMAND_HOST_STOP, null, resourceId);
            await delay(100);
            
            // Cancel the reader to discard any buffered data, then get a fresh reader
            console.log('Draining serial buffer...');
            try {
                await resource.reader.cancel();
                resource.reader.releaseLock();
            } catch (e) {
                console.log('Reader cancel:', e.message);
            }
            
            // Get fresh reader after draining
            resource.reader = port.readable.getReader();
            resource.readBuffer = new Uint8Array();
            resource.readState = 'delimiter';

            // Show connected in modal
            infoEl.innerHTML = '<span class="text-green-500"><i class="fas fa-check-circle mr-1"></i>Connected</span>';
            
            // Initialize per-resource Opus decoder
            await initResourceOpusDecoder(resourceId);
            
            // Start read loop - this will receive HELLO which triggers the handshake:
            // HELLO -> CONFIG (from us) -> VERSION (from ESP32) -> GROUP (from us)
            // The handshake is handled in handleSerialPacket's HELLO and VERSION cases
            readSerialLoop(resourceId);
            
            // Brief delay to let read loop start
            await delay(10);

            // Don't send GROUP here - wait for the handshake flow:
            // 1. ESP32 sends HELLO on connect/reboot
            // 2. We send CONFIG in response to HELLO
            // 3. ESP32 initializes SA818 module and sends VERSION
            // 4. We send GROUP in response to VERSION (if radio module found)
            // This ensures UHF modules get properly initialized with sa818_uhf driver
            
            // Update main UI
            renderResources();

        } catch (e) {
            console.error('Failed to connect:', e);
            resource.isConnected = false;

            if (e.name === 'NotFoundError') {
                infoEl.innerHTML = '<span class="text-gray-500">No port selected</span>';
            } else {
                infoEl.innerHTML = `<span class="text-red-500">Error: ${e.message}</span>`;
            }
            renderResources();
        }
    }

    async function disconnectResource(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        if (resource.reader) {
            try {
                await resource.reader.cancel();
                resource.reader.releaseLock();
            } catch (e) {}
            resource.reader = null;
        }

        if (resource.writer) {
            try {
                resource.writer.releaseLock();
            } catch (e) {}
            resource.writer = null;
        }

        if (resource.port) {
            try {
                await resource.port.close();
            } catch (e) {}
            resource.port = null;
        }

        resource.isConnected = false;
        resource.handshakeComplete = false;
        resource.rfModuleType = null;
        
        // Clean up per-resource Opus decoder
        const decoder = resourceOpusDecoders.get(resourceId);
        if (decoder) {
            decoder.close();
            resourceOpusDecoders.delete(resourceId);
            console.log(`Closed per-resource Opus decoder for resource ${resourceId}`);
        }
        
        renderResources();
    }

    async function readSerialLoop(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.reader) return;

        let currentCmd = 0;
        let currentLen = 0;
        let overrunCount = 0;
        const maxOverruns = 15; // Allow more overruns before giving up
        let lastOverrunTime = 0;
        let successfulReads = 0;

        while (resource.port) {
            try {
                const { value, done } = await resource.reader.read();
                if (done) {
                    console.log(`Serial port closed for resource ${resourceId}`);
                    break;
                }
                
                // Decay overrun count after consistent successful reads
                successfulReads++;
                if (successfulReads >= 10 && overrunCount > 0) {
                    overrunCount--;
                    successfulReads = 0;
                }

                // Limit buffer size to prevent memory issues
                const maxBufferSize = 131072; // 128KB max - larger buffer for audio streaming
                if (resource.readBuffer.length > maxBufferSize) {
                    console.warn(`Resource ${resourceId}: Read buffer overflow, resetting`);
                    resource.readBuffer = new Uint8Array();
                    resource.readState = 'delimiter';
                }

                // Append to buffer
                const newBuffer = new Uint8Array(resource.readBuffer.length + value.length);
                newBuffer.set(resource.readBuffer);
                newBuffer.set(value, resource.readBuffer.length);
                resource.readBuffer = newBuffer;

                // Process buffer with iteration limit to prevent blocking
                let processing = true;
                let iterations = 0;
                const maxIterations = 200; // More iterations for heavy audio streams
                
                while (processing && iterations < maxIterations) {
                    iterations++;
                    switch (resource.readState) {
                        case 'delimiter':
                            let delimIdx = -1;
                            for (let i = 0; i <= resource.readBuffer.length - 4; i++) {
                                if (resource.readBuffer[i] === 0xDE &&
                                    resource.readBuffer[i + 1] === 0xAD &&
                                    resource.readBuffer[i + 2] === 0xBE &&
                                    resource.readBuffer[i + 3] === 0xEF) {
                                    delimIdx = i;
                                    break;
                                }
                            }
                            if (delimIdx !== -1) {
                                resource.readBuffer = resource.readBuffer.slice(delimIdx + 4);
                                resource.readState = 'header';
                            } else {
                                resource.readBuffer = resource.readBuffer.slice(Math.max(0, resource.readBuffer.length - 3));
                                processing = false;
                            }
                            break;

                        case 'header':
                            if (resource.readBuffer.length >= 3) {
                                currentCmd = resource.readBuffer[0];
                                currentLen = resource.readBuffer[1] | (resource.readBuffer[2] << 8);
                                resource.readBuffer = resource.readBuffer.slice(3);
                                resource.readState = 'payload';
                            } else {
                                processing = false;
                            }
                            break;

                        case 'payload':
                            if (resource.readBuffer.length >= currentLen) {
                                const payload = resource.readBuffer.slice(0, currentLen);
                                resource.readBuffer = resource.readBuffer.slice(currentLen);
                                handleSerialPacket(resourceId, currentCmd, payload);
                                resource.readState = 'delimiter';
                            } else {
                                processing = false;
                            }
                            break;
                    }
                }

            } catch (e) {
                // BufferOverrunError means ESP32 is flooding data faster than we can read
                if (e.name === 'BufferOverrunError') {
                    const now = Date.now();
                    overrunCount++;
                    successfulReads = 0; // Reset success counter
                    
                    // Only log occasionally to prevent log spam
                    if (overrunCount === 1 || (now - lastOverrunTime) > 1000) {
                        console.warn(`Resource ${resourceId}: Buffer overrun ${overrunCount}/${maxOverruns}`);
                        lastOverrunTime = now;
                    }
                    
                    // Reset buffer state - just drop what we have and resync
                    resource.readBuffer = new Uint8Array();
                    resource.readState = 'delimiter';
                    
                    // Only try recovery after multiple overruns
                    if (overrunCount === 5) {
                        try {
                            // Send STOP to pause ESP32
                            await sendSerialPacket(COMMAND_HOST_STOP, null, resourceId);
                            await delay(200); // Give ESP32 time to stop
                            // Resume with GROUP
                            await sendGroupCommand(resource);
                        } catch (stopErr) {
                            console.warn('Failed to send recovery commands:', stopErr);
                        }
                    }
                    
                    if (overrunCount >= maxOverruns) {
                        console.error(`Resource ${resourceId}: Too many buffer overruns, disconnecting`);
                        break;
                    }
                    // Continue trying - don't break immediately
                    continue;
                } else {
                    console.error(`Serial read error for resource ${resourceId}:`, e);
                    break;
                }
            }
        }

        // Connection lost - clean up everything and update UI
        // IMPORTANT: Re-lookup resource from array because saveResource() may have replaced the object
        const currentResource = resources.find(r => r.id === resourceId);
        if (currentResource && currentResource.isConnected) {
            console.log(`Connection lost for resource ${resourceId}`);
            
            // IMMEDIATELY mark as disconnected and null out writer to prevent race conditions
            // This must happen synchronously before any await
            currentResource.isConnected = false;
            currentResource.handshakeComplete = false;
            currentResource.rfModuleType = null;
            
            // Null out writer immediately to prevent any writes
            const writerToRelease = currentResource.writer;
            currentResource.writer = null;
            
            // Null out reader
            const readerToRelease = currentResource.reader;
            currentResource.reader = null;
            
            // Store port reference for cleanup
            const portToClose = currentResource.port;
            currentResource.port = null;
            
            // Update UI immediately AND schedule another render for next tick
            renderResources();
            setTimeout(() => renderResources(), 0);
            
            // Play bonk to alert user
            playBonkSound();
            
            // Stop any active transmission on this resource
            if (activeTxIds.includes(resourceId)) {
                activeTxIds = activeTxIds.filter(id => id !== resourceId);
                currentResource.busy = false;
                currentResource.recordingType = null;
                console.log(`Stopped TX on disconnected resource ${resourceId}`);
            }
            
            // End any RX session
            if (currentResource.busy && currentResource.recordingType === 'rx') {
                currentResource.busy = false;
                currentResource.recordingType = null;
                if (currentResource.rxTimeout) {
                    clearTimeout(currentResource.rxTimeout);
                    currentResource.rxTimeout = null;
                }
            }
            
            // Now do async cleanup (these can happen after UI update)
            if (readerToRelease) {
                try {
                    readerToRelease.releaseLock();
                } catch (e) {}
            }
            
            if (writerToRelease) {
                try {
                    writerToRelease.releaseLock();
                } catch (e) {}
            }
            
            if (portToClose) {
                try {
                    await portToClose.close();
                } catch (e) {}
            }
            
            // Clean up per-resource Opus decoder
            const decoder = resourceOpusDecoders.get(resourceId);
            if (decoder) {
                decoder.close();
                resourceOpusDecoders.delete(resourceId);
            }
            
            // Reset jitter buffer in audio nodes
            const nodes = resourceAudioNodes.get(resourceId);
            if (nodes) {
                nodes.jitterBuffer = [];
                nodes.playbackStarted = false;
            }
        }
    }

    async function handleSerialPacket(resourceId, command, payload) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        switch (command) {
            case COMMAND_HELLO:
                // ESP32 has rebooted or just started - send CONFIG to initialize SA818 module
                console.log(`Resource ${resourceId}: HELLO received (ESP32 ready)`);
                // Send CONFIG command to trigger SA818 handshake and get VERSION back
                // This is critical for UHF modules - they need CONFIG to select the right SA818 driver
                resource.handshakeComplete = false;
                resource.rfModuleType = null;
                await sendConfigCommand(resource);
                break;

            case COMMAND_VERSION:
                // Parse VERSION struct: ver(u16), radioModuleStatus(char), windowSize(u32), rfModuleType(u32), features(u8)
                // Total: 2 + 1 + 4 + 4 + 1 = 12 bytes
                if (payload.length >= 12) {
                    const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
                    resource.firmwareVersion = view.getUint16(0, true);
                    const radioStatus = String.fromCharCode(payload[2]);
                    resource.flowControlWindow = view.getUint32(3, true);
                    const rfModuleType = view.getUint32(7, true); // 0=VHF, 1=UHF
                    const features = payload[11];
                    const hasHl = (features & 0x01) !== 0;
                    const hasPhysPtt = (features & 0x02) !== 0;
                    
                    // Store RF module type on resource
                    resource.rfModuleType = rfModuleType;
                    resource.hasHighLowPower = hasHl;
                    resource.hasPhysicalPtt = hasPhysPtt;
                    
                    const rfTypeStr = rfModuleType === RF_MODULE_UHF ? 'UHF (SA818-U)' : 'VHF (SA818-V)';
                    console.log(`Resource ${resourceId}: VERSION - fw:v${resource.firmwareVersion}, radio:${radioStatus}, window:${resource.flowControlWindow}, rf:${rfTypeStr}, HL:${hasHl}, PTT:${hasPhysPtt}`);
                    
                    if (radioStatus === 'f') {
                        resource.handshakeComplete = true;
                        console.log(`Resource ${resourceId}: Handshake complete - ${rfTypeStr} module ready`);
                        
                        // Check for frequency/module type mismatch (only show once per connect)
                        const mismatchError = checkFrequencyMismatch(resource, rfModuleType);
                        if (mismatchError) {
                            showError('Configuration Error', mismatchError);
                            console.error(`Resource ${resourceId}: ${mismatchError}`);
                        } else {
                            // Frequency matches module type - send GROUP to tune the radio
                            await sendGroupCommand(resource);
                        }
                    } else if (radioStatus === 'x') {
                        console.error(`Resource ${resourceId}: Radio module not found! Check connections.`);
                        resource.handshakeComplete = false;
                    } else {
                        console.warn(`Resource ${resourceId}: Unknown radio status: ${radioStatus}`);
                    }
                    
                    // Update UI to show module type
                    renderResources();
                }
                break;

            case COMMAND_WINDOW_UPDATE:
                // Flow control window update (4 bytes, little-endian u32)
                if (payload.length >= 4) {
                    const view = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
                    resource.flowControlWindow = view.getUint32(0, true);
                    // Process any queued packets
                    processFlowControlQueue(resourceId);
                }
                break;

            case COMMAND_RX_AUDIO:
                handleRxAudio(resourceId, payload);
                break;

            case COMMAND_PHYS_PTT_DOWN:
                if (!resource.busy) {
                    startRxSession(resourceId);
                }
                break;

            case COMMAND_PHYS_PTT_UP:
                if (resource.busy && resource.recordingType === 'rx') {
                    endRxSession(resourceId);
                }
                break;

            case COMMAND_SMETER_REPORT:
                if (payload.length >= 1) {
                    const rssi = payload[0];
                    const nodes = resourceAudioNodes.get(resourceId);
                    if (nodes) {
                        nodes.lastRssi = Math.min(8, Math.max(0, rssi)); // Clamp to 0-8
                        // Use lightweight update for RSSI during active RX
                        // This avoids full DOM rebuilds for frequent S-meter updates
                        if (resource.busy && resource.recordingType === 'rx') {
                            updateRxIndicatorOnly(
                                resourceId, 
                                true, 
                                nodes.lastRssi, 
                                nodes.currentCallerId
                            );
                        }
                    }
                }
                break;

            default:
                // Debug commands (0x01-0x05) can be logged
                if (command >= 0x01 && command <= 0x05) {
                    const msg = new TextDecoder().decode(payload);
                    console.log(`Resource ${resourceId} DEBUG[${command}]: ${msg}`);
                } else {
                    console.log(`Unknown command 0x${command.toString(16)} from resource ${resourceId}`);
                }
        }
    }

    // Flow control queue processing
    function processFlowControlQueue(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.pendingTxQueue || resource.pendingTxQueue.length === 0) return;

        while (resource.pendingTxQueue.length > 0) {
            const packet = resource.pendingTxQueue[0];
            const packetSize = 7 + (packet.data ? packet.data.byteLength : 0);
            
            if (resource.flowControlWindow >= packetSize) {
                resource.pendingTxQueue.shift();
                resource.flowControlWindow -= packetSize;
                // Actually send the packet
                resource.writer.write(packet.rawPacket).catch(e => {
                    console.error(`Failed to send queued packet:`, e);
                });
            } else {
                // Not enough window, wait for more space
                break;
            }
        }
    }

    function handleRxAudio(resourceId, payload) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !audioContext) return;
        
        // Use per-resource decoder to prevent multi-resource audio garbling
        // Fall back to global decoder if per-resource not available
        let decoder = resourceOpusDecoders.get(resourceId);
        if (!decoder) {
            decoder = opusDecoder;
            if (!decoder) return;
        }

        // Decode Opus packet to PCM
        try {
            let pcmInt16 = null;
            
            // Handle different decoder APIs
            if (decoder._isLibopus) {
                decoder.input(new Uint8Array(payload));
                pcmInt16 = decoder.output();
            } else if (decoder._isWebCodecs) {
                pcmInt16 = decoder.decode(new Uint8Array(payload));
            } else {
                pcmInt16 = decoder.decode(new Uint8Array(payload));
            }
            
            if (!pcmInt16 || pcmInt16.length === 0) return;

            // Convert Int16 to Float32 for Web Audio
            const pcmFloat = new Float32Array(pcmInt16.length);
            let maxAmplitude = 0;
            for (let i = 0; i < pcmInt16.length; i++) {
                pcmFloat[i] = pcmInt16[i] / 32768;
                maxAmplitude = Math.max(maxAmplitude, Math.abs(pcmFloat[i]));
            }

            // Skip if audio is essentially silent (below -40dB threshold)
            // This prevents "phantom RX" from noise/static triggering sessions
            if (maxAmplitude < 0.01) return;

            // Now we have real audio - start RX session if needed
            if (!resource.busy || resource.recordingType !== 'rx') {
                startRxSession(resourceId);
            }

            // Reset RX timeout - end session after 500ms of no audio
            if (resource.rxTimeout) {
                clearTimeout(resource.rxTimeout);
            }
            resource.rxTimeout = setTimeout(() => {
                if (resource.busy && resource.recordingType === 'rx') {
                    endRxSession(resourceId);
                }
            }, 500);

            // Update VU meter if this resource is selected
            if (resource.selected) {
                updateVuMeter('rx', pcmFloat);
            }

            // Feed audio to DTMF decoder for alias decoding and emergency detection
            if (aliasDecodingEnabled || emergencyEnabled) {
                const dtmfDecoder = resourceDtmfDecoders.get(resourceId);
                if (dtmfDecoder) {
                    dtmfDecoder.processAudio(pcmFloat);
                }
            }

            // Get nodes for this resource
            const nodes = resourceAudioNodes.get(resourceId);
            if (!nodes) return;
            
            // Add to jitter buffer
            if (!nodes.jitterBuffer) {
                nodes.jitterBuffer = [];
            }
            nodes.jitterBuffer.push(pcmFloat);
            
            // Start playback when we have enough buffered (3 frames = ~60ms)
            const JITTER_BUFFER_TARGET = 3;
            if (!nodes.playbackStarted && nodes.jitterBuffer.length >= JITTER_BUFFER_TARGET) {
                nodes.playbackStarted = true;
                nodes.nextPlayTime = audioContext.currentTime + 0.02; // 20ms initial delay
            }
            
            // Play frames from jitter buffer
            if (nodes.playbackStarted && nodes.jitterBuffer.length > 0) {
                const now = audioContext.currentTime;
                
                // Process all available frames in buffer
                while (nodes.jitterBuffer.length > 0) {
                    const frame = nodes.jitterBuffer.shift();
                    
                    // Create audio buffer
                    const audioBuffer = audioContext.createBuffer(1, frame.length, OPUS_SAMPLE_RATE);
                    const channelData = audioBuffer.getChannelData(0);
                    
                    // Simple copy - let Web Audio handle the scheduling
                    channelData.set(frame);
                    
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(nodes.gainNode);
                    source.connect(nodes.recordingGainNode); // Full-volume recording
                    
                    // If we've fallen behind, catch up
                    if (nodes.nextPlayTime < now) {
                        nodes.nextPlayTime = now + 0.01;
                    }
                    
                    source.start(nodes.nextPlayTime);
                    nodes.nextPlayTime += frame.length / OPUS_SAMPLE_RATE;
                    
                    // Limit how far ahead we schedule
                    if (nodes.nextPlayTime > now + 0.2) {
                        break;
                    }
                }
            }

            // Add to recording buffer
            if (resource.recordingBuffer && resource.busy) {
                resource.recordingBuffer.push(...pcmFloat);
            }

        } catch (e) {
            console.error('Opus decode error:', e);
        }

        // Handle patching/rebroadcast
        if (resource.patch && patchedResources.length === 2) {
            const otherResourceId = patchedResources.find(id => id !== resourceId);
            if (otherResourceId && rebroadcastState.sourceId === null) {
                const otherResource = resources.find(r => r.id === otherResourceId);
                if (otherResource && otherResource.isConnected && !otherResource.busy) {
                    startRebroadcast(resourceId, otherResourceId);
                }
            }

            if (rebroadcastState.sourceId === resourceId) {
                sendSerialPacket(COMMAND_HOST_TX_AUDIO, payload.buffer, rebroadcastState.targetId);
            }
        }
    }

    function startRxSession(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        // Don't restart if already in RX session for this resource
        if (resource.busy && resource.recordingType === 'rx') return;

        resource.busy = true;
        resource.recordingType = 'rx';

        // Reset scheduled playback time for fresh RX session
        const nodes = resourceAudioNodes.get(resourceId);
        if (nodes) {
            nodes.nextPlayTime = 0; // Will be set properly on first audio packet
            nodes.lastSample = 0; // Reset crossfade sample
            nodes.jitterBuffer = []; // Clear jitter buffer
            nodes.playbackStarted = false; // Reset playback flag
        }
        
        // Reset decoder to clear any stale frames
        if (opusDecoder && opusDecoder.reset) {
            opusDecoder.reset();
        }

        // Check if this is an emergency resource - force volume to 100%
        if (activeEmergencyResourceIds.has(resourceId)) {
            if (nodes && audioContext) {
                nodes.gainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.05);
            }
        } else {
            if (nodes && audioContext) {
                let targetVolume = resource.selected ? selectedVolume : resource.volume;
                if (isMuted && !resource.selected) targetVolume = 0;
                if (activeTxIds.length > 0 && !resource.selected) targetVolume = 0;
                nodes.gainNode.gain.linearRampToValueAtTime(volumeToGain(targetVolume), audioContext.currentTime + 0.05);
            }
        }

        startRecording(resourceId, 'rx');
        
        // Update stack light for RX state change
        updateStackLight();
        
        // Throttled render - don't render more than once per 100ms
        throttledRenderResources();
    }

    // Throttled render function to prevent UI lockup during rapid RX updates
    // Uses requestAnimationFrame for smoother updates synced to display refresh
    let renderThrottleTimer = null;
    let renderAnimationFrame = null;
    const RENDER_THROTTLE_MS = 150; // Throttle renders to max ~6-7 per second during RX
    
    function throttledRenderResources() {
        if (renderThrottleTimer) return; // Already scheduled
        renderThrottleTimer = setTimeout(() => {
            renderThrottleTimer = null;
            // Use requestAnimationFrame to sync with display refresh
            if (renderAnimationFrame) {
                cancelAnimationFrame(renderAnimationFrame);
            }
            renderAnimationFrame = requestAnimationFrame(() => {
                renderAnimationFrame = null;
                renderResources();
            });
        }, RENDER_THROTTLE_MS);
    }
    
    // Lightweight RX indicator update - only updates specific elements without full render
    // This allows more frequent visual feedback without DOM thrashing
    // Uses requestAnimationFrame to batch updates with display refresh
    let rxIndicatorAnimationFrames = new Map(); // Track pending updates per resource
    
    function updateRxIndicatorOnly(resourceId, isReceiving, rssiLevel, callerId) {
        // Store pending update data
        if (!rxIndicatorAnimationFrames.has(resourceId)) {
            rxIndicatorAnimationFrames.set(resourceId, {
                pending: true,
                isReceiving,
                rssiLevel,
                callerId
            });
            
            // Schedule the actual DOM update via requestAnimationFrame
            requestAnimationFrame(() => {
                const data = rxIndicatorAnimationFrames.get(resourceId);
                if (!data || !data.pending) return;
                
                applyRxIndicatorUpdate(resourceId, data.isReceiving, data.rssiLevel, data.callerId);
                rxIndicatorAnimationFrames.delete(resourceId);
            });
        } else {
            // Update pending data (will be used when the frame fires)
            const data = rxIndicatorAnimationFrames.get(resourceId);
            data.isReceiving = isReceiving;
            data.rssiLevel = rssiLevel;
            data.callerId = callerId;
        }
    }
    
    function applyRxIndicatorUpdate(resourceId, isReceiving, rssiLevel, callerId) {
        const card = document.querySelector(`[data-resource-id="${resourceId}"]`);
        if (!card) return;
        
        // Update RX/TX indicator icon
        const indicatorSpan = card.querySelector('.rx-tx-indicator');
        if (indicatorSpan) {
            if (isReceiving) {
                indicatorSpan.innerHTML = '<i class="fas fa-volume-up text-blue-500 animate-pulse"></i>';
            } else {
                indicatorSpan.innerHTML = '<i class="fas fa-volume-off text-gray-300 dark:text-gray-600"></i>';
            }
        }
        
        // Update RSSI meter
        const rssiMeter = card.querySelector('.rssi-meter');
        if (rssiMeter && showRssi) {
            rssiMeter.innerHTML = createRssiMeterHtml(isReceiving ? rssiLevel : 0);
        }
        
        // Update caller ID
        const callerIdSpan = card.querySelector('.caller-id-display');
        if (callerIdSpan) {
            callerIdSpan.style.opacity = isReceiving ? '1' : '0';
            callerIdSpan.textContent = callerId || '';
            callerIdSpan.title = callerId || '';
        }
    }

    function endRxSession(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        // Close audio
        const nodes = resourceAudioNodes.get(resourceId);
        if (nodes && audioContext) {
            nodes.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.05);
        }

        // Stop recording
        stopRecording(resourceId);

        resource.busy = false;
        resource.recordingType = null;

        // Reset VU meter if this was a selected resource and no other selected resources are receiving
        if (resource.selected) {
            const otherSelectedReceiving = resources.some(r => 
                r.id !== resourceId && r.selected && r.busy && r.recordingType === 'rx'
            );
            if (!otherSelectedReceiving) {
                resetVuMeter();
            }
        }

        // Check for queued priority tone
        checkQueuedPriorityTone(resourceId);

        // End rebroadcast if this was the source
        if (rebroadcastState.sourceId === resourceId) {
            endRebroadcast();
        }

        // Join-as-available: If this resource was pending for TX and general TX is active, join the transmission
        if (pendingTxIds.includes(resourceId) && activeTxIds.length > 0 && !isTransmittingPages) {
            joinActiveTransmission(resourceId);
        }

        // Clear any pending RX timeout
        if (resource.rxTimeout) {
            clearTimeout(resource.rxTimeout);
            resource.rxTimeout = null;
        }

        // Update stack light for RX state change
        updateStackLight();

        throttledRenderResources();
    }

    async function joinActiveTransmission(resourceId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource || !resource.isConnected) return;

        // Remove from pending
        pendingTxIds = pendingTxIds.filter(id => id !== resourceId);

        // Add to active TX
        activeTxIds.push(resourceId);
        resource.busy = true;
        resource.recordingType = 'tx';

        // Tune and key up
        await sendGroupCommand(resource);
        await sendSerialPacket(COMMAND_HOST_PTT_DOWN, null, resourceId);
        startRecording(resourceId, 'tx');

        console.log(`Resource "${resource.name}" joined active transmission`);
        renderResources();
    }

    async function startRebroadcast(sourceId, targetId) {
        rebroadcastState = { sourceId, targetId };

        const targetResource = resources.find(r => r.id === targetId);
        if (targetResource) {
            await sendGroupCommand(targetResource);
            await sendSerialPacket(COMMAND_HOST_PTT_DOWN, null, targetId);
            targetResource.busy = true;
            targetResource.recordingType = 'tx';
        }
    }

    async function endRebroadcast() {
        if (rebroadcastState.targetId) {
            const targetId = rebroadcastState.targetId;
            
            // Send multiple PTT_UP commands to ensure radio unkeys
            // This prevents stuck transmissions when breaking patches mid-rebroadcast
            console.log(`Ending rebroadcast on resource ${targetId} - sending PTT_UP`);
            await sendSerialPacket(COMMAND_HOST_PTT_UP, null, targetId);
            
            // Small delay then send again for reliability
            await new Promise(resolve => setTimeout(resolve, 50));
            await sendSerialPacket(COMMAND_HOST_PTT_UP, null, targetId);

            const targetResource = resources.find(r => r.id === targetId);
            if (targetResource) {
                // Stop any recording that may be in progress
                if (targetResource.busy && targetResource.recordingType === 'tx') {
                    stopRecording(targetId);
                }
                targetResource.busy = false;
                targetResource.recordingType = null;
            }
        }

        rebroadcastState = { sourceId: null, targetId: null };
        renderResources();
    }

    // ============================================================================
    // EMERGENCY SYSTEM
    // ============================================================================

    function triggerEmergency(resourceId, callerId) {
        const resource = resources.find(r => r.id === resourceId);
        if (!resource) return;

        const event = {
            id: nextEmergencyId++,
            resourceId,
            resourceName: resource.name,
            callerId: callerId || 'Unknown',
            timestamp: Date.now(),
            acknowledged: false
        };

        emergencyEvents.unshift(event);

        if (emergencyEvents.length > 10) {
            emergencyEvents.pop();
        }

        activeEmergencyResourceIds.add(resourceId);

        const nodes = resourceAudioNodes.get(resourceId);
        if (nodes && audioContext) {
            nodes.gainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.05);
        }

        startEmergencyWhoop();
        updateEmergencyUI();
        renderResources();
        
        // Update stack light for emergency state
        updateStackLight();
    }

    function updateEmergencyUI() {
        const unacknowledged = emergencyEvents.filter(e => !e.acknowledged);
        const badge = document.getElementById('emergencyBadge');
        const btn = document.getElementById('emergencyBtn');
        const ackBtn = document.getElementById('acknowledgeEmergencyBtn');

        if (unacknowledged.length > 0) {
            badge.textContent = unacknowledged.length;
            badge.classList.remove('hidden');
            btn.classList.add('emergency-icon-active');
            ackBtn.disabled = false;
            ackBtn.classList.remove('bg-gray-400');
            ackBtn.classList.add('bg-red-500', 'hover:bg-red-600', 'emergency-btn-pulse');
        } else {
            badge.classList.add('hidden');
            btn.classList.remove('emergency-icon-active');
            ackBtn.disabled = true;
            ackBtn.classList.add('bg-gray-400');
            ackBtn.classList.remove('bg-red-500', 'hover:bg-red-600', 'emergency-btn-pulse');
        }

        renderEmergencyList();
    }

    function renderEmergencyList() {
        const list = document.getElementById('emergencyList');
        const noMsg = document.getElementById('noEmergenciesMsg');

        if (emergencyEvents.length === 0) {
            list.innerHTML = '';
            noMsg.classList.remove('hidden');
            return;
        }

        noMsg.classList.add('hidden');
        list.innerHTML = emergencyEvents.map(event => `
            <div class="list-item ${!event.acknowledged ? 'border-l-4 border-red-500' : ''}">
                <div class="flex-1 min-w-0">
                    <div class="text-sm font-medium ${!event.acknowledged ? 'text-red-500' : ''}">${escapeHtml(event.resourceName)}</div>
                    <div class="text-xs text-gray-500">
                        ${escapeHtml(event.callerId)} • ${new Date(event.timestamp).toLocaleTimeString()}
                    </div>
                </div>
                <button onclick="deleteEmergencyEvent(${event.id})" 
                        class="p-1 text-gray-500 hover:text-red-500 transition-colors" title="Delete">
                    <i class="fas fa-trash text-xs"></i>
                </button>
            </div>
        `).join('');
    }

    function acknowledgeAllEmergencies() {
        emergencyEvents.forEach(event => {
            event.acknowledged = true;
        });

        activeEmergencyResourceIds.clear();
        stopEmergencyWhoop();

        resources.forEach(resource => {
            if (resource.busy && resource.recordingType === 'rx') {
                const nodes = resourceAudioNodes.get(resource.id);
                if (nodes && audioContext) {
                    const targetVolume = resource.selected ? selectedVolume : resource.volume;
                    nodes.gainNode.gain.linearRampToValueAtTime(volumeToGain(targetVolume), audioContext.currentTime + 0.05);
                }
            }
        });

        updateEmergencyUI();
        renderResources();
        
        // Update stack light for emergency state
        updateStackLight();
    }

    function deleteEmergencyEvent(eventId) {
        const idx = emergencyEvents.findIndex(e => e.id === eventId);
        if (idx > -1) {
            const event = emergencyEvents[idx];
            emergencyEvents.splice(idx, 1);

            const stillActive = emergencyEvents.some(e => !e.acknowledged && e.resourceId === event.resourceId);
            if (!stillActive) {
                activeEmergencyResourceIds.delete(event.resourceId);
            }

            if (!emergencyEvents.some(e => !e.acknowledged)) {
                stopEmergencyWhoop();
            }

            updateEmergencyUI();
            renderResources();
        }
    }

    function toggleEmergencySettings() {
        const panel = document.getElementById('emergencySettingsPanel');
        panel.classList.toggle('hidden');
    }

    function saveEmergencySettings() {
        // Get values from the emergency settings panel
        emergencyEnabled = document.getElementById('enableEmergencyAlerts').checked;
        emergencyTriggerDtmf = document.getElementById('emergencyTriggerDtmf').value.trim().toUpperCase();
        
        // Save to localStorage
        const settings = JSON.parse(localStorage.getItem('dispatchConsoleSettings') || '{}');
        settings.emergencyEnabled = emergencyEnabled;
        settings.emergencyTriggerDtmf = emergencyTriggerDtmf;
        localStorage.setItem('dispatchConsoleSettings', JSON.stringify(settings));
        
        console.log('🚨 Emergency settings saved:', {
            emergencyEnabled,
            emergencyTriggerDtmf,
            triggerLength: emergencyTriggerDtmf.length
        });
        
        // Hide the settings panel
        document.getElementById('emergencySettingsPanel').classList.add('hidden');
    }

    // ============================================================================
    // RADIO ALIAS SYSTEM
    // ============================================================================

    function renderAliasList() {
        const list = document.getElementById('aliasList');
        const noMsg = document.getElementById('noAliasesMsg');
        const deleteBtn = document.getElementById('deleteAliasBtn');

        if (radioAliases.length === 0) {
            list.innerHTML = '';
            noMsg.classList.remove('hidden');
            deleteBtn.disabled = true;
            return;
        }

        noMsg.classList.add('hidden');
        list.innerHTML = radioAliases.map(alias => `
            <div class="list-item ${selectedAliasIds.includes(alias.id) ? 'selected' : ''}" 
                 onclick="toggleAliasSelection(${alias.id})">
                <div class="flex-1 min-w-0">
                    <div class="text-sm font-medium">${escapeHtml(alias.name)}</div>
                    <div class="text-xs text-gray-500 font-mono">${escapeHtml(alias.dtmfId)}</div>
                </div>
            </div>
        `).join('');

        deleteBtn.disabled = selectedAliasIds.length === 0;
    }

    function toggleAliasSelection(aliasId) {
        const idx = selectedAliasIds.indexOf(aliasId);
        if (idx > -1) {
            selectedAliasIds.splice(idx, 1);
        } else {
            selectedAliasIds.push(aliasId);
        }
        renderAliasList();
    }

    function showAddAliasModal() {
        document.getElementById('editingAliasId').value = '';
        document.getElementById('aliasEditTitle').textContent = 'Add Radio Alias';
        document.getElementById('aliasName').value = '';
        document.getElementById('aliasDtmfId').value = '';
        showModal('aliasEditModal');
    }

    function saveAlias(event) {
        event.preventDefault();

        const name = document.getElementById('aliasName').value.trim();
        const dtmfId = sanitizeDTMFString(document.getElementById('aliasDtmfId').value.trim());

        if (!name || !dtmfId || dtmfId.length < 1 || dtmfId.length > 10) {
            return;
        }

        const editingId = document.getElementById('editingAliasId').value;

        if (editingId) {
            const alias = radioAliases.find(a => a.id === parseInt(editingId));
            if (alias) {
                alias.name = name;
                alias.dtmfId = dtmfId;
            }
        } else {
            radioAliases.push({
                id: nextAliasId++,
                name,
                dtmfId
            });
        }

        hideModal('aliasEditModal');
        renderAliasList();
        saveToLocalStorage();
    }

    function deleteSelectedAliases() {
        if (selectedAliasIds.length === 0) return;

        showConfirmDialog(
            'Delete Aliases',
            `Are you sure you want to delete ${selectedAliasIds.length} alias(es)?`,
            () => {
                radioAliases = radioAliases.filter(a => !selectedAliasIds.includes(a.id));
                selectedAliasIds = [];
                renderAliasList();
                saveToLocalStorage();
            }
        );
    }

    function toggleAliasSettings() {
        const panel = document.getElementById('aliasSettingsPanel');
        panel.classList.toggle('hidden');
    }

    // ============================================================================
    // RESOURCE & PAGE CRUD
    // ============================================================================

    function addResource() {
        document.getElementById('editingResourceId').value = '';
        document.getElementById('resourceModalTitle').textContent = 'Add Resource';
        document.getElementById('resourceForm').reset();
        document.getElementById('operationMode').value = 'simplex';
        document.getElementById('toneType').value = 'csq';
        document.getElementById('squelchLevel').value = '4';
        document.getElementById('squelchValue').textContent = '4';
        document.getElementById('txPowerHigh').checked = true;  // Default to high power
        document.getElementById('bandwidthNarrow').checked = true;  // Default to narrow
        updateOperationModeFields();
        updateToneFields();
        document.getElementById('resourceConnectionInfo').innerHTML = '<span class="text-gray-500">Status: Not Connected</span>';
        document.getElementById('resourceDeleteSection').classList.add('hidden');  // Hide delete for new resources
        showModal('resourceModal');
    }

    function editResource(id) {
        const resource = resources.find(r => r.id === id);
        if (!resource) return;

        document.getElementById('editingResourceId').value = id;
        document.getElementById('resourceModalTitle').textContent = 'Edit Resource';
        document.getElementById('resourceName').value = resource.name;
        document.getElementById('frequency').value = resource.frequency;
        document.getElementById('operationMode').value = resource.mode;
        document.getElementById('transmitFrequency').value = resource.transmitFrequency || '';
        document.getElementById('toneType').value = resource.toneType;
        document.getElementById('ctcssCode').value = resource.ctcssTone || '123.0';
        document.getElementById('squelchLevel').value = resource.squelchLevel || 4;
        document.getElementById('squelchValue').textContent = resource.squelchLevel || 4;
        
        // Set TX power radio buttons
        if (resource.txPower === 'low') {
            document.getElementById('txPowerLow').checked = true;
        } else {
            document.getElementById('txPowerHigh').checked = true;
        }
        
        // Set bandwidth radio buttons
        if (resource.bandwidth === 'wide') {
            document.getElementById('bandwidthWide').checked = true;
        } else {
            document.getElementById('bandwidthNarrow').checked = true;
        }

        updateOperationModeFields();
        updateToneFields();

        const infoEl = document.getElementById('resourceConnectionInfo');
        infoEl.innerHTML = resource.isConnected 
            ? '<span class="text-green-500"><i class="fas fa-check-circle mr-1"></i>Connected</span>'
            : '<span class="text-gray-500">Status: Not Connected</span>';

        document.getElementById('resourceDeleteSection').classList.remove('hidden');  // Show delete for existing resources
        showModal('resourceModal');
    }

    function saveResource(event) {
        event.preventDefault();

        const name = document.getElementById('resourceName').value.trim();
        const frequency = parseFloat(document.getElementById('frequency').value);
        const mode = document.getElementById('operationMode').value;
        const toneType = document.getElementById('toneType').value;

        if (!name || !frequency) return;

        const resourceData = {
            name,
            frequency,
            mode,
            toneType,
            transmitFrequency: mode === 'half-duplex' ? parseFloat(document.getElementById('transmitFrequency').value) : null,
            ctcssTone: toneType === 'ctcss' ? document.getElementById('ctcssCode').value : null,
            squelchLevel: parseInt(document.getElementById('squelchLevel').value),
            txPower: document.querySelector('input[name="txPower"]:checked').value,
            bandwidth: document.querySelector('input[name="bandwidth"]:checked').value
        };

        const editingId = document.getElementById('editingResourceId').value;
        let resourceToUpdate = null;

        if (editingId) {
            const idx = resources.findIndex(r => r.id === parseInt(editingId));
            if (idx > -1) {
                resources[idx] = { ...resources[idx], ...resourceData };
                resourceToUpdate = resources[idx];
            }
        } else {
            const newResource = {
                ...resourceData,
                id: nextResourceId++,
                volume: unselectedVolume,
                selected: false,
                busy: false,
                priority: false,
                patch: false,
                recordings: [],
                isRecording: false,
                recordingType: null,
                port: null,
                writer: null,
                reader: null,
                readBuffer: new Uint8Array(),
                readState: 'delimiter',
                isConnected: false,
                handshakeComplete: false,
                rfModuleType: null
            };
            resources.push(newResource);

            if (audioContext) {
                setupResourceAudio(newResource);
            }
        }

        // If the resource is connected, check for frequency mismatch and send GROUP command
        if (resourceToUpdate && resourceToUpdate.isConnected && resourceToUpdate.handshakeComplete) {
            // Check if the new frequency matches the connected module type
            const mismatchError = checkFrequencyMismatch(resourceToUpdate, resourceToUpdate.rfModuleType);
            if (mismatchError) {
                showError('Configuration Error', mismatchError);
                console.error(`Resource ${resourceToUpdate.id}: ${mismatchError}`);
                // Don't send GROUP command if there's a mismatch
            } else {
                console.log(`Applying settings to connected resource ${resourceToUpdate.id}`);
                sendGroupCommand(resourceToUpdate);
            }
        }

        hideModal('resourceModal');
        renderResources();
        saveToLocalStorage();
    }

    function confirmDeleteResource(id) {
        const resource = resources.find(r => r.id === id);
        if (!resource) return;

        showConfirmDialog(
            'Delete Resource',
            `Are you sure you want to delete "${resource.name}"?`,
            () => deleteResource(id)
        );
    }

    function confirmDeleteResourceFromModal() {
        const editingId = document.getElementById('editingResourceId').value;
        if (!editingId) return;
        
        const id = parseInt(editingId);
        const resource = resources.find(r => r.id === id);
        if (!resource) return;

        hideModal('resourceModal');
        showConfirmDialog(
            'Delete Resource',
            `Are you sure you want to delete "${resource.name}"?`,
            () => deleteResource(id)
        );
    }

    function deleteResource(id) {
        disconnectResource(id);
        stopPriorityTimer(id);
        removeResourceAudio(id);
        expandedResources.delete(id);

        patchedResources = patchedResources.filter(pId => pId !== id);
        resources = resources.filter(r => r.id !== id);

        renderResources();
        saveToLocalStorage();
    }

    function updateOperationModeFields() {
        const mode = document.getElementById('operationMode').value;
        document.getElementById('transmitFreqDiv').classList.toggle('hidden', mode !== 'half-duplex');
    }

    function updateToneFields() {
        const toneType = document.getElementById('toneType').value;
        document.getElementById('ctcssDiv').classList.toggle('hidden', toneType !== 'ctcss');
    }

    // Page CRUD
    function addPage() {
        document.getElementById('editingPageId').value = '';
        document.getElementById('pageModalTitle').textContent = 'Add Page';
        document.getElementById('pageForm').reset();
        document.getElementById('pageType').value = 'dtmf';
        updatePageTypeFields();
        showModal('pageModal');
    }

    function editPage(id) {
        const page = pages.find(p => p.id === id);
        if (!page) return;

        document.getElementById('editingPageId').value = id;
        document.getElementById('pageModalTitle').textContent = 'Edit Page';
        document.getElementById('pageName').value = page.name;
        document.getElementById('pageType').value = page.type;
        document.getElementById('dtmfString').value = page.dtmfString || '';
        document.getElementById('firstToneFreq').value = page.firstToneFreq || '';
        document.getElementById('secondToneFreq').value = page.secondToneFreq || '';

        updatePageTypeFields();
        showModal('pageModal');
    }

    function savePage(event) {
        event.preventDefault();

        const name = document.getElementById('pageName').value.trim();
        const type = document.getElementById('pageType').value;

        if (!name) return;

        const pageData = { name, type };

        if (type === 'dtmf') {
            const dtmfString = sanitizeDTMFString(document.getElementById('dtmfString').value);
            if (!dtmfString) return;
            pageData.dtmfString = dtmfString;
        } else {
            const firstToneFreq = parseFloat(document.getElementById('firstToneFreq').value);
            const secondToneFreq = parseFloat(document.getElementById('secondToneFreq').value);
            if (!firstToneFreq || !secondToneFreq) return;
            pageData.firstToneFreq = firstToneFreq;
            pageData.secondToneFreq = secondToneFreq;
        }

        const editingId = document.getElementById('editingPageId').value;

        if (editingId) {
            const idx = pages.findIndex(p => p.id === parseInt(editingId));
            if (idx > -1) {
                pages[idx] = { ...pages[idx], ...pageData };
            }
        } else {
            pageData.id = nextPageId++;
            pages.push(pageData);
        }

        hideModal('pageModal');
        renderPages();
        saveToLocalStorage();
    }

    function confirmDeletePage(id) {
        const page = pages.find(p => p.id === id);
        if (!page) return;

        showConfirmDialog(
            'Delete Page',
            `Are you sure you want to delete "${page.name}"?`,
            () => {
                stackedPages = stackedPages.filter(pId => pId !== id);
                pages = pages.filter(p => p.id !== id);
                renderPages();
                saveToLocalStorage();
            }
        );
    }

    function updatePageTypeFields() {
        const type = document.getElementById('pageType').value;
        document.getElementById('dtmfDiv').classList.toggle('hidden', type !== 'dtmf');
        document.getElementById('twoToneDiv').classList.toggle('hidden', type !== '2tone');
    }

    // ============================================================================
    // SETTINGS
    // ============================================================================

    function applySettings() {
        consoleName = document.getElementById('consoleNameInput').value.trim() || consoleName;
        document.getElementById('consoleTitle').textContent = consoleName;

        currentTheme = document.getElementById('themeSelect').value;
        applyTheme();

        showClock = document.getElementById('showClockToggle').checked;
        clockFormat = document.getElementById('clockFormatSelect').value;
        updateClockDisplay();

        selectedVolume = parseInt(document.getElementById('selectedVolumeSlider').value);
        unselectedVolume = parseInt(document.getElementById('unselectedVolumeSlider').value);

        showRssi = document.getElementById('showRssiToggle').checked;

        consoleIdEnabled = document.getElementById('enableConsoleIdToggle').checked;
        consoleIdString = sanitizeDTMFString(document.getElementById('consoleIdString').value);
        consoleIdTiming = document.getElementById('consoleIdTiming').value;

        aliasDecodingEnabled = document.getElementById('enableAliasDecoding').checked;

        emergencyEnabled = document.getElementById('enableEmergencyAlerts').checked;
        emergencyTriggerDtmf = sanitizeDTMFString(document.getElementById('emergencyTriggerDtmf').value);
        
        console.log('Settings saved - Emergency config:', {
            emergencyEnabled: emergencyEnabled,
            emergencyTriggerDtmf: emergencyTriggerDtmf,
            triggerLength: emergencyTriggerDtmf.length
        });

        renderResources();
        saveToLocalStorage();
    }

    // ============================================================================
    // CONFIGURATION IMPORT/EXPORT/CLEAR
    // ============================================================================

    function exportConfiguration() {
        const config = {
            version: 'v2.4',
            exportDate: new Date().toISOString(),
            consoleName,
            currentTheme,
            showClock,
            clockFormat,
            selectedVolume,
            unselectedVolume,
            masterVolume,
            micVolume,
            showRssi,
            stackLightEnabled,
            pttKey,
            consoleIdEnabled,
            consoleIdString,
            consoleIdTiming,
            aliasDecodingEnabled,
            emergencyEnabled,
            emergencyTriggerDtmf,
            radioAliases,
            nextAliasId,
            resources: resources.map(r => ({
                id: r.id,
                name: r.name,
                frequency: r.frequency,
                mode: r.mode,
                transmitFrequency: r.transmitFrequency,
                toneType: r.toneType,
                ctcssTone: r.ctcssTone,
                squelchLevel: r.squelchLevel,
                txPower: r.txPower || 'high',
                bandwidth: r.bandwidth || 'narrow',
                volume: r.volume,
                selected: r.selected,
                priority: r.priority,
                patch: r.patch
            })),
            nextResourceId,
            pages,
            nextPageId
        };

        const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dispatch-console-config-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log('Configuration exported successfully');
    }

    function importConfiguration(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const config = JSON.parse(e.target.result);
                
                // Validate it's a dispatch console config
                if (!config.consoleName && !config.resources) {
                    throw new Error('Invalid configuration file');
                }

                // Apply all settings
                if (config.consoleName) consoleName = config.consoleName;
                if (config.currentTheme) currentTheme = config.currentTheme;
                if (config.showClock !== undefined) showClock = config.showClock;
                if (config.clockFormat) clockFormat = config.clockFormat;
                if (config.selectedVolume !== undefined) selectedVolume = config.selectedVolume;
                if (config.unselectedVolume !== undefined) unselectedVolume = config.unselectedVolume;
                if (config.masterVolume !== undefined) masterVolume = config.masterVolume;
                if (config.micVolume !== undefined) micVolume = config.micVolume;
                if (config.showRssi !== undefined) showRssi = config.showRssi;
                if (config.stackLightEnabled !== undefined) stackLightEnabled = config.stackLightEnabled;
                if (config.pttKey) pttKey = config.pttKey;
                if (config.consoleIdEnabled !== undefined) consoleIdEnabled = config.consoleIdEnabled;
                if (config.consoleIdString) consoleIdString = config.consoleIdString;
                if (config.consoleIdTiming) consoleIdTiming = config.consoleIdTiming;
                if (config.aliasDecodingEnabled !== undefined) aliasDecodingEnabled = config.aliasDecodingEnabled;
                if (config.emergencyEnabled !== undefined) emergencyEnabled = config.emergencyEnabled;
                if (config.emergencyTriggerDtmf) emergencyTriggerDtmf = config.emergencyTriggerDtmf;
                if (config.radioAliases) radioAliases = config.radioAliases;
                if (config.nextAliasId) nextAliasId = config.nextAliasId;
                if (config.pages) pages = config.pages;
                if (config.nextPageId) nextPageId = config.nextPageId;

                if (config.resources) {
                    // Disconnect existing resources first
                    resources.forEach(r => {
                        if (r.isConnected) {
                            try { r.port?.close(); } catch(e) {}
                        }
                    });
                    
                    resources = config.resources.map(r => ({
                        ...r,
                        busy: false,
                        recordings: [],
                        isRecording: false,
                        recordingType: null,
                        port: null,
                        writer: null,
                        reader: null,
                        isConnected: false
                    }));
                    if (config.nextResourceId) nextResourceId = config.nextResourceId;
                }

                // Apply theme and update UI
                applyTheme();
                updateClockDisplay();
                document.getElementById('consoleTitle').textContent = consoleName;
                
                // Save and refresh
                saveToLocalStorage();
                renderResources();
                renderPages();
                populateSettingsForm();

                console.log('Configuration imported successfully from:', config.exportDate || 'unknown date');
                showSuccess('Import Complete', 'Configuration imported successfully!');
                
            } catch (err) {
                console.error('Failed to import configuration:', err);
                showError('Import Failed', 'Failed to import configuration: ' + err.message);
            }
        };
        reader.readAsText(file);
        
        // Reset the file input so same file can be selected again
        event.target.value = '';
    }

    function clearConfiguration() {
        showConfirmDialog(
            'Clear All Configuration?',
            'This will reset all settings to defaults, remove all resources, aliases, and pages. This cannot be undone!',
            () => {
                // Disconnect all resources first
                resources.forEach(r => {
                    if (r.isConnected) {
                        try { r.port?.close(); } catch(e) {}
                    }
                });

                // Clear localStorage
                localStorage.removeItem('dispatchConsoleV2');
                localStorage.removeItem('dispatchConsoleSettings');

                // Reset to defaults
                consoleName = 'Common Dispatch';
                currentTheme = 'light';
                selectedVolume = 7;
                unselectedVolume = 5;
                masterVolume = 5;
                micVolume = 6;
                showRssi = true;
                showClock = false;
                clockFormat = '12';
                pttKey = ' ';
                consoleIdEnabled = false;
                consoleIdString = '';
                consoleIdTiming = 'end';
                aliasDecodingEnabled = true;
                emergencyEnabled = true;
                emergencyTriggerDtmf = '';
                radioAliases = [];
                nextAliasId = 1;
                resources = [];
                nextResourceId = 1;
                pages = [];
                nextPageId = 1;

                // Update clock display
                updateClockDisplay();

                // Update UI
                applyTheme();
                document.getElementById('consoleTitle').textContent = consoleName;
                renderResources();
                renderPages();
                populateSettingsForm();

                console.log('Configuration cleared');
                showSuccess('Configuration Cleared', 'All settings have been reset to defaults.');
                hideModal('settingsModal');
            }
        );
    }

    function populateSettingsForm() {
        document.getElementById('consoleNameInput').value = consoleName;
        document.getElementById('themeSelect').value = currentTheme;
        document.getElementById('showClockToggle').checked = showClock;
        document.getElementById('clockFormatSelect').value = clockFormat;
        document.getElementById('clockFormatOption').classList.toggle('hidden', !showClock);
        document.getElementById('selectedVolumeSlider').value = selectedVolume;
        document.getElementById('selectedVolumeValue').textContent = selectedVolume;
        document.getElementById('unselectedVolumeSlider').value = unselectedVolume;
        document.getElementById('unselectedVolumeValue').textContent = unselectedVolume;
        document.getElementById('showRssiToggle').checked = showRssi;
        document.getElementById('stackLightToggle').checked = stackLightEnabled;
        document.getElementById('stackLightSettingsBtn').classList.toggle('hidden', !stackLightEnabled);
        document.getElementById('enableConsoleIdToggle').checked = consoleIdEnabled;
        document.getElementById('consoleIdString').value = consoleIdString;
        document.getElementById('consoleIdTiming').value = consoleIdTiming;
        document.getElementById('enableAliasDecoding').checked = aliasDecodingEnabled;
        document.getElementById('enableEmergencyAlerts').checked = emergencyEnabled;
        document.getElementById('emergencyTriggerDtmf').value = emergencyTriggerDtmf;
        updatePttKeyDisplay();
    }

    // Clock display functions
    function toggleClockOptions() {
        const clockEnabled = document.getElementById('showClockToggle').checked;
        document.getElementById('clockFormatOption').classList.toggle('hidden', !clockEnabled);
    }

    function updateClockDisplay() {
        const clockEl = document.getElementById('clockDisplay');
        const timeEl = document.getElementById('clockTime');
        
        if (showClock) {
            clockEl.classList.remove('hidden');
            
            // Start interval if not running
            if (!clockInterval) {
                clockInterval = setInterval(updateClockTime, 1000);
                updateClockTime(); // Update immediately
            }
        } else {
            clockEl.classList.add('hidden');
            
            // Stop interval
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
        }
    }

    function updateClockTime() {
        const timeEl = document.getElementById('clockTime');
        if (!timeEl) return;
        
        const now = new Date();
        let hours = now.getHours();
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        
        if (clockFormat === '12') {
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            timeEl.textContent = `${hours}:${minutes}:${seconds} ${ampm}`;
        } else {
            timeEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes}:${seconds}`;
        }
    }

    function updatePttKeyDisplay() {
        const display = document.getElementById('pttKeyDisplay');
        let keyName = pttKey;
        if (keyName === ' ') keyName = 'Space';
        if (keyName === 'Control') keyName = 'Ctrl';
        display.textContent = `Currently: ${keyName}`;
    }

    function startKeyBinding() {
        isBindingKey = true;
        const btn = document.getElementById('setPttKeyBtn');
        btn.textContent = 'Press any key...';
        btn.classList.add('bg-yellow-500');
        btn.classList.remove('bg-blue-500');
    }

    function captureKey(e) {
        if (!isBindingKey) return;

        e.preventDefault();
        pttKey = e.key;
        isBindingKey = false;

        const btn = document.getElementById('setPttKeyBtn');
        btn.textContent = 'Click to Set Key';
        btn.classList.remove('bg-yellow-500');
        btn.classList.add('bg-blue-500');

        updatePttKeyDisplay();
        saveToLocalStorage();
    }

    // ============================================================================
    // LOCAL STORAGE
    // ============================================================================

    function saveToLocalStorage() {
        const data = {
            consoleName,
            currentTheme,
            showClock,
            clockFormat,
            selectedVolume,
            unselectedVolume,
            masterVolume,
            micVolume,
            showRssi,
            stackLightEnabled,
            pttKey,
            consoleIdEnabled,
            consoleIdString,
            consoleIdTiming,
            aliasDecodingEnabled,
            emergencyEnabled,
            emergencyTriggerDtmf,
            radioAliases,
            nextAliasId,
            resources: resources.map(r => ({
                id: r.id,
                name: r.name,
                frequency: r.frequency,
                mode: r.mode,
                transmitFrequency: r.transmitFrequency,
                toneType: r.toneType,
                ctcssTone: r.ctcssTone,
                squelchLevel: r.squelchLevel,
                txPower: r.txPower || 'high',
                bandwidth: r.bandwidth || 'narrow',
                volume: r.volume,
                selected: r.selected,
                priority: r.priority,
                patch: r.patch
            })),
            nextResourceId,
            pages,
            nextPageId
        };

        try {
            localStorage.setItem('dispatchConsoleV2', JSON.stringify(data));
        } catch (e) {
            console.error('Failed to save to localStorage:', e);
        }
    }

    function loadFromLocalStorage() {
        try {
            const saved = localStorage.getItem('dispatchConsoleV2');
            if (!saved) return;

            const data = JSON.parse(saved);

            consoleName = data.consoleName || consoleName;
            currentTheme = data.currentTheme || currentTheme;
            showClock = data.showClock ?? showClock;
            clockFormat = data.clockFormat || clockFormat;
            selectedVolume = data.selectedVolume ?? selectedVolume;
            unselectedVolume = data.unselectedVolume ?? unselectedVolume;
            masterVolume = data.masterVolume ?? masterVolume;
            micVolume = data.micVolume ?? micVolume;
            showRssi = data.showRssi ?? showRssi;
            stackLightEnabled = data.stackLightEnabled ?? stackLightEnabled;
            pttKey = data.pttKey || pttKey;
            consoleIdEnabled = data.consoleIdEnabled ?? consoleIdEnabled;
            consoleIdString = data.consoleIdString || consoleIdString;
            consoleIdTiming = data.consoleIdTiming || consoleIdTiming;
            aliasDecodingEnabled = data.aliasDecodingEnabled ?? aliasDecodingEnabled;
            emergencyEnabled = data.emergencyEnabled ?? emergencyEnabled;
            emergencyTriggerDtmf = data.emergencyTriggerDtmf || emergencyTriggerDtmf;
            radioAliases = data.radioAliases || [];
            nextAliasId = data.nextAliasId || 1;
            
            console.log('Settings loaded - Emergency config:', {
                emergencyEnabled: emergencyEnabled,
                emergencyTriggerDtmf: emergencyTriggerDtmf,
                triggerLength: emergencyTriggerDtmf ? emergencyTriggerDtmf.length : 0
            });

            if (data.resources) {
                resources = data.resources.map(r => ({
                    ...r,
                    busy: false,
                    recordings: [],
                    isRecording: false,
                    recordingType: null,
                    port: null,
                    writer: null,
                    reader: null,
                    readBuffer: new Uint8Array(),
                    readState: 'delimiter',
                    isConnected: false
                }));
                nextResourceId = data.nextResourceId || 1;
            }

            if (data.pages) {
                pages = data.pages;
                nextPageId = data.nextPageId || 1;
            }

        } catch (e) {
            console.error('Failed to load from localStorage:', e);
        }
    }

    // ============================================================================
    // EVENT LISTENERS & INITIALIZATION
    // ============================================================================

    function initEventListeners() {
        // Master volume
        document.getElementById('masterVolume').addEventListener('input', (e) => {
            masterVolume = parseInt(e.target.value);
            document.getElementById('masterVolumeDisplay').textContent = masterVolume;
            if (masterGainNode) {
                masterGainNode.gain.linearRampToValueAtTime(volumeToGain(masterVolume), audioContext.currentTime + 0.05);
            }
        });

        // Mic volume
        document.getElementById('micVolume').addEventListener('input', (e) => {
            micVolume = parseInt(e.target.value);
            document.getElementById('micVolumeDisplay').textContent = micVolume;
            if (micGainNode) {
                micGainNode.gain.linearRampToValueAtTime(volumeToGain(micVolume), audioContext.currentTime + 0.05);
            }
        });

        // Mute button
        document.getElementById('muteBtn').addEventListener('click', toggleMute);

        // General transmit button
        const txBtn = document.getElementById('generalTransmitBtn');
        txBtn.addEventListener('mousedown', () => { initAudioContext(); startGeneralTransmit(); });
        txBtn.addEventListener('mouseup', stopTransmit);
        txBtn.addEventListener('mouseleave', stopTransmit);
        txBtn.addEventListener('touchstart', (e) => { e.preventDefault(); initAudioContext(); startGeneralTransmit(); }, { passive: false });
        txBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopTransmit(); }, { passive: false });

        // Paging transmit button - also serves as cancel button when paging in progress
        document.getElementById('transmitStackBtn').addEventListener('click', () => {
            initAudioContext();
            if (isTransmittingPages) {
                cancelPaging();
            } else {
                transmitStackedPages();
            }
        });

        // Alert tone buttons
        const alert1Btn = document.getElementById('alertTone1Btn');
        alert1Btn.addEventListener('mousedown', () => { initAudioContext(); startAlertTone1(); });
        alert1Btn.addEventListener('mouseup', () => stopAlertTone1());
        alert1Btn.addEventListener('mouseleave', () => stopAlertTone1());
        alert1Btn.addEventListener('touchstart', (e) => { e.preventDefault(); initAudioContext(); startAlertTone1(); }, { passive: false });
        alert1Btn.addEventListener('touchend', (e) => { e.preventDefault(); stopAlertTone1(); }, { passive: false });

        const alert2Btn = document.getElementById('alertTone2Btn');
        alert2Btn.addEventListener('mousedown', () => { initAudioContext(); startAlertTone2(); });
        alert2Btn.addEventListener('mouseup', () => stopAlertTone2());
        alert2Btn.addEventListener('mouseleave', () => stopAlertTone2());
        alert2Btn.addEventListener('touchstart', (e) => { e.preventDefault(); initAudioContext(); startAlertTone2(); }, { passive: false });
        alert2Btn.addEventListener('touchend', (e) => { e.preventDefault(); stopAlertTone2(); }, { passive: false });

        // Add buttons
        document.getElementById('addResourceBtn').addEventListener('click', addResource);
        document.getElementById('addPageBtn').addEventListener('click', addPage);

        // Modal buttons
        document.getElementById('settingsBtn').addEventListener('click', () => { populateSettingsForm(); showModal('settingsModal'); });
        document.getElementById('aliasesBtn').addEventListener('click', () => { renderAliasList(); showModal('aliasesModal'); });
        document.getElementById('emergencyBtn').addEventListener('click', () => { 
            renderEmergencyList(); 
            // Populate emergency settings fields
            document.getElementById('enableEmergencyAlerts').checked = emergencyEnabled;
            document.getElementById('emergencyTriggerDtmf').value = emergencyTriggerDtmf;
            showModal('emergencyModal'); 
        });
        document.getElementById('helpBtn').addEventListener('click', () => { currentHelpTopic = null; showModal('helpModal'); });

        // Settings controls
        document.getElementById('selectedVolumeSlider').addEventListener('input', (e) => {
            document.getElementById('selectedVolumeValue').textContent = e.target.value;
        });
        document.getElementById('unselectedVolumeSlider').addEventListener('input', (e) => {
            document.getElementById('unselectedVolumeValue').textContent = e.target.value;
        });
        document.getElementById('enableConsoleIdToggle').addEventListener('change', (e) => {
            document.getElementById('consoleIdSettings').classList.toggle('hidden', !e.target.checked);
        });
        document.getElementById('setPttKeyBtn').addEventListener('click', startKeyBinding);

        // Keyboard PTT - only active when no modal is open
        document.addEventListener('keydown', (e) => {
            if (isBindingKey) {
                captureKey(e);
                return;
            }

            // Check if any modal is open - if so, don't trigger PTT
            if (isAnyModalOpen()) {
                return;
            }

            if (e.key === pttKey && !isPttDown && !e.repeat) {
                e.preventDefault();
                isPttDown = true;
                initAudioContext();
                startGeneralTransmit();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === pttKey && isPttDown) {
                e.preventDefault();
                isPttDown = false;
                stopTransmit();
            }
        });

        // Click anywhere to init audio context
        document.addEventListener('click', () => initAudioContext(), { once: true });
    }

    function initUI() {
        // Set initial values
        document.getElementById('consoleTitle').textContent = consoleName;
        document.getElementById('consoleNameInput').value = consoleName;
        document.getElementById('themeSelect').value = currentTheme;
        document.getElementById('showClockToggle').checked = showClock;
        document.getElementById('clockFormatSelect').value = clockFormat;
        document.getElementById('clockFormatOption').classList.toggle('hidden', !showClock);
        document.getElementById('masterVolume').value = masterVolume;
        document.getElementById('masterVolumeDisplay').textContent = masterVolume;
        document.getElementById('micVolume').value = micVolume;
        document.getElementById('micVolumeDisplay').textContent = micVolume;
        document.getElementById('selectedVolumeSlider').value = selectedVolume;
        document.getElementById('selectedVolumeValue').textContent = selectedVolume;
        document.getElementById('unselectedVolumeSlider').value = unselectedVolume;
        document.getElementById('unselectedVolumeValue').textContent = unselectedVolume;
        document.getElementById('showRssiToggle').checked = showRssi;
        document.getElementById('enableConsoleIdToggle').checked = consoleIdEnabled;
        document.getElementById('consoleIdString').value = consoleIdString;
        document.getElementById('consoleIdTiming').value = consoleIdTiming;
        document.getElementById('consoleIdSettings').classList.toggle('hidden', !consoleIdEnabled);
        document.getElementById('enableAliasDecoding').checked = aliasDecodingEnabled;
        document.getElementById('enableEmergencyAlerts').checked = emergencyEnabled;
        document.getElementById('emergencyTriggerDtmf').value = emergencyTriggerDtmf;

        updatePttKeyDisplay();
    }

    // Initialize on DOM ready
    document.addEventListener('DOMContentLoaded', () => {
        loadFromLocalStorage();
        initTheme();
        initUI();
        initEventListeners();
        updateClockDisplay();
        renderResources();
        renderPages();

        console.log('Common Dispatch Console v2.4 initialized');
    });
    </script>
</body>
</html>
